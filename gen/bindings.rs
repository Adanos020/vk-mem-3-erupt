/* automatically generated by rust-bindgen 0.61.0 */

pub const VMA_VULKAN_VERSION: u32 = 1003000;
pub const VMA_DEDICATED_ALLOCATION: u32 = 1;
pub const VMA_BIND_MEMORY2: u32 = 1;
pub const VMA_MEMORY_BUDGET: u32 = 1;
pub const VMA_BUFFER_DEVICE_ADDRESS: u32 = 1;
pub const VMA_MEMORY_PRIORITY: u32 = 1;
pub const VMA_EXTERNAL_MEMORY: u32 = 1;
pub const VMA_STATS_STRING_ENABLED: u32 = 1;
pub type VkBool32 = u32;
pub type VkDeviceSize = u64;
pub type VkFlags = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkBuffer_T {
    _unused: [u8; 0],
}
pub type VkBuffer = *mut VkBuffer_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkImage_T {
    _unused: [u8; 0],
}
pub type VkImage = *mut VkImage_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkInstance_T {
    _unused: [u8; 0],
}
pub type VkInstance = *mut VkInstance_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDevice_T {
    _unused: [u8; 0],
}
pub type VkPhysicalDevice = *mut VkPhysicalDevice_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDevice_T {
    _unused: [u8; 0],
}
pub type VkDevice = *mut VkDevice_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkCommandBuffer_T {
    _unused: [u8; 0],
}
pub type VkCommandBuffer = *mut VkCommandBuffer_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDeviceMemory_T {
    _unused: [u8; 0],
}
pub type VkDeviceMemory = *mut VkDeviceMemory_T;
pub const VkResult_VK_SUCCESS: VkResult = 0;
pub const VkResult_VK_NOT_READY: VkResult = 1;
pub const VkResult_VK_TIMEOUT: VkResult = 2;
pub const VkResult_VK_EVENT_SET: VkResult = 3;
pub const VkResult_VK_EVENT_RESET: VkResult = 4;
pub const VkResult_VK_INCOMPLETE: VkResult = 5;
pub const VkResult_VK_ERROR_OUT_OF_HOST_MEMORY: VkResult = -1;
pub const VkResult_VK_ERROR_OUT_OF_DEVICE_MEMORY: VkResult = -2;
pub const VkResult_VK_ERROR_INITIALIZATION_FAILED: VkResult = -3;
pub const VkResult_VK_ERROR_DEVICE_LOST: VkResult = -4;
pub const VkResult_VK_ERROR_MEMORY_MAP_FAILED: VkResult = -5;
pub const VkResult_VK_ERROR_LAYER_NOT_PRESENT: VkResult = -6;
pub const VkResult_VK_ERROR_EXTENSION_NOT_PRESENT: VkResult = -7;
pub const VkResult_VK_ERROR_FEATURE_NOT_PRESENT: VkResult = -8;
pub const VkResult_VK_ERROR_INCOMPATIBLE_DRIVER: VkResult = -9;
pub const VkResult_VK_ERROR_TOO_MANY_OBJECTS: VkResult = -10;
pub const VkResult_VK_ERROR_FORMAT_NOT_SUPPORTED: VkResult = -11;
pub const VkResult_VK_ERROR_FRAGMENTED_POOL: VkResult = -12;
pub const VkResult_VK_ERROR_UNKNOWN: VkResult = -13;
pub const VkResult_VK_ERROR_OUT_OF_POOL_MEMORY: VkResult = -1000069000;
pub const VkResult_VK_ERROR_INVALID_EXTERNAL_HANDLE: VkResult = -1000072003;
pub const VkResult_VK_ERROR_FRAGMENTATION: VkResult = -1000161000;
pub const VkResult_VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS: VkResult = -1000257000;
pub const VkResult_VK_PIPELINE_COMPILE_REQUIRED: VkResult = 1000297000;
pub const VkResult_VK_ERROR_SURFACE_LOST_KHR: VkResult = -1000000000;
pub const VkResult_VK_ERROR_NATIVE_WINDOW_IN_USE_KHR: VkResult = -1000000001;
pub const VkResult_VK_SUBOPTIMAL_KHR: VkResult = 1000001003;
pub const VkResult_VK_ERROR_OUT_OF_DATE_KHR: VkResult = -1000001004;
pub const VkResult_VK_ERROR_INCOMPATIBLE_DISPLAY_KHR: VkResult = -1000003001;
pub const VkResult_VK_ERROR_VALIDATION_FAILED_EXT: VkResult = -1000011001;
pub const VkResult_VK_ERROR_INVALID_SHADER_NV: VkResult = -1000012000;
pub const VkResult_VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT: VkResult = -1000158000;
pub const VkResult_VK_ERROR_NOT_PERMITTED_KHR: VkResult = -1000174001;
pub const VkResult_VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT: VkResult = -1000255000;
pub const VkResult_VK_THREAD_IDLE_KHR: VkResult = 1000268000;
pub const VkResult_VK_THREAD_DONE_KHR: VkResult = 1000268001;
pub const VkResult_VK_OPERATION_DEFERRED_KHR: VkResult = 1000268002;
pub const VkResult_VK_OPERATION_NOT_DEFERRED_KHR: VkResult = 1000268003;
pub const VkResult_VK_ERROR_COMPRESSION_EXHAUSTED_EXT: VkResult = -1000338000;
pub const VkResult_VK_ERROR_OUT_OF_POOL_MEMORY_KHR: VkResult = -1000069000;
pub const VkResult_VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR: VkResult = -1000072003;
pub const VkResult_VK_ERROR_FRAGMENTATION_EXT: VkResult = -1000161000;
pub const VkResult_VK_ERROR_NOT_PERMITTED_EXT: VkResult = -1000174001;
pub const VkResult_VK_ERROR_INVALID_DEVICE_ADDRESS_EXT: VkResult = -1000257000;
pub const VkResult_VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR: VkResult = -1000257000;
pub const VkResult_VK_PIPELINE_COMPILE_REQUIRED_EXT: VkResult = 1000297000;
pub const VkResult_VK_ERROR_PIPELINE_COMPILE_REQUIRED_EXT: VkResult = 1000297000;
pub const VkResult_VK_RESULT_MAX_ENUM: VkResult = 2147483647;
pub type VkResult = ::std::os::raw::c_int;
pub const VkStructureType_VK_STRUCTURE_TYPE_APPLICATION_INFO: VkStructureType = 0;
pub const VkStructureType_VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO: VkStructureType = 1;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO: VkStructureType = 2;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO: VkStructureType = 3;
pub const VkStructureType_VK_STRUCTURE_TYPE_SUBMIT_INFO: VkStructureType = 4;
pub const VkStructureType_VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO: VkStructureType = 5;
pub const VkStructureType_VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE: VkStructureType = 6;
pub const VkStructureType_VK_STRUCTURE_TYPE_BIND_SPARSE_INFO: VkStructureType = 7;
pub const VkStructureType_VK_STRUCTURE_TYPE_FENCE_CREATE_INFO: VkStructureType = 8;
pub const VkStructureType_VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO: VkStructureType = 9;
pub const VkStructureType_VK_STRUCTURE_TYPE_EVENT_CREATE_INFO: VkStructureType = 10;
pub const VkStructureType_VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO: VkStructureType = 11;
pub const VkStructureType_VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO: VkStructureType = 12;
pub const VkStructureType_VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO: VkStructureType = 13;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO: VkStructureType = 14;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO: VkStructureType = 15;
pub const VkStructureType_VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO: VkStructureType = 16;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO: VkStructureType = 17;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO: VkStructureType = 18;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO:
    VkStructureType = 19;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO:
    VkStructureType = 20;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO:
    VkStructureType = 21;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO: VkStructureType =
    22;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO:
    VkStructureType = 23;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO:
    VkStructureType = 24;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO:
    VkStructureType = 25;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO:
    VkStructureType = 26;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO: VkStructureType =
    27;
pub const VkStructureType_VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO: VkStructureType = 28;
pub const VkStructureType_VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO: VkStructureType = 29;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO: VkStructureType = 30;
pub const VkStructureType_VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO: VkStructureType = 31;
pub const VkStructureType_VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO: VkStructureType = 32;
pub const VkStructureType_VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO: VkStructureType = 33;
pub const VkStructureType_VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO: VkStructureType = 34;
pub const VkStructureType_VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET: VkStructureType = 35;
pub const VkStructureType_VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET: VkStructureType = 36;
pub const VkStructureType_VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO: VkStructureType = 37;
pub const VkStructureType_VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO: VkStructureType = 38;
pub const VkStructureType_VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO: VkStructureType = 39;
pub const VkStructureType_VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO: VkStructureType = 40;
pub const VkStructureType_VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO: VkStructureType = 41;
pub const VkStructureType_VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO: VkStructureType = 42;
pub const VkStructureType_VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO: VkStructureType = 43;
pub const VkStructureType_VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER: VkStructureType = 44;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER: VkStructureType = 45;
pub const VkStructureType_VK_STRUCTURE_TYPE_MEMORY_BARRIER: VkStructureType = 46;
pub const VkStructureType_VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO: VkStructureType = 47;
pub const VkStructureType_VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO: VkStructureType = 48;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES: VkStructureType =
    1000094000;
pub const VkStructureType_VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO: VkStructureType = 1000157000;
pub const VkStructureType_VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO: VkStructureType = 1000157001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES:
    VkStructureType = 1000083000;
pub const VkStructureType_VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS: VkStructureType =
    1000127000;
pub const VkStructureType_VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO: VkStructureType =
    1000127001;
pub const VkStructureType_VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO: VkStructureType =
    1000060000;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO: VkStructureType =
    1000060003;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO:
    VkStructureType = 1000060004;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO: VkStructureType = 1000060005;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO: VkStructureType =
    1000060006;
pub const VkStructureType_VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO: VkStructureType =
    1000060013;
pub const VkStructureType_VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO: VkStructureType =
    1000060014;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES: VkStructureType =
    1000070000;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO: VkStructureType =
    1000070001;
pub const VkStructureType_VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2: VkStructureType =
    1000146000;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2: VkStructureType =
    1000146001;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2:
    VkStructureType = 1000146002;
pub const VkStructureType_VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2: VkStructureType = 1000146003;
pub const VkStructureType_VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2: VkStructureType =
    1000146004;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2: VkStructureType =
    1000059000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2: VkStructureType =
    1000059001;
pub const VkStructureType_VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2: VkStructureType = 1000059002;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2: VkStructureType = 1000059003;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2: VkStructureType =
    1000059004;
pub const VkStructureType_VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2: VkStructureType = 1000059005;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2: VkStructureType =
    1000059006;
pub const VkStructureType_VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2: VkStructureType =
    1000059007;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2:
    VkStructureType = 1000059008;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES:
    VkStructureType = 1000117000;
pub const VkStructureType_VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO:
    VkStructureType = 1000117001;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO: VkStructureType =
    1000117002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO : VkStructureType = 1000117003 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO: VkStructureType =
    1000053000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES: VkStructureType =
    1000053001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES: VkStructureType =
    1000053002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES:
    VkStructureType = 1000120000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO: VkStructureType = 1000145000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES:
    VkStructureType = 1000145001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES:
    VkStructureType = 1000145002;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2: VkStructureType = 1000145003;
pub const VkStructureType_VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO: VkStructureType =
    1000156000;
pub const VkStructureType_VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO: VkStructureType =
    1000156001;
pub const VkStructureType_VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO: VkStructureType =
    1000156002;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO: VkStructureType =
    1000156003;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES:
    VkStructureType = 1000156004;
pub const VkStructureType_VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES:
    VkStructureType = 1000156005;
pub const VkStructureType_VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO:
    VkStructureType = 1000085000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO:
    VkStructureType = 1000071000;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES: VkStructureType =
    1000071001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO: VkStructureType =
    1000071002;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES: VkStructureType =
    1000071003;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES: VkStructureType =
    1000071004;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO: VkStructureType =
    1000072000;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO: VkStructureType =
    1000072001;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO: VkStructureType =
    1000072002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO: VkStructureType =
    1000112000;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES: VkStructureType = 1000112001;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO: VkStructureType = 1000113000;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO: VkStructureType =
    1000077000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO:
    VkStructureType = 1000076000;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES: VkStructureType =
    1000076001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES:
    VkStructureType = 1000168000;
pub const VkStructureType_VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT: VkStructureType =
    1000168001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES:
    VkStructureType = 1000063000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES: VkStructureType =
    49;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES: VkStructureType =
    50;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES: VkStructureType =
    51;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES: VkStructureType =
    52;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO: VkStructureType =
    1000147000;
pub const VkStructureType_VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2: VkStructureType = 1000109000;
pub const VkStructureType_VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2: VkStructureType = 1000109001;
pub const VkStructureType_VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2: VkStructureType = 1000109002;
pub const VkStructureType_VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2: VkStructureType = 1000109003;
pub const VkStructureType_VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2: VkStructureType = 1000109004;
pub const VkStructureType_VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO: VkStructureType = 1000109005;
pub const VkStructureType_VK_STRUCTURE_TYPE_SUBPASS_END_INFO: VkStructureType = 1000109006;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES: VkStructureType =
    1000177000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES: VkStructureType =
    1000196000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES:
    VkStructureType = 1000180000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES:
    VkStructureType = 1000082000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES:
    VkStructureType = 1000197000;
pub const VkStructureType_VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO:
    VkStructureType = 1000161000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES:
    VkStructureType = 1000161001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES:
    VkStructureType = 1000161002;
pub const VkStructureType_VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO : VkStructureType = 1000161003 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT : VkStructureType = 1000161004 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES:
    VkStructureType = 1000199000;
pub const VkStructureType_VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE:
    VkStructureType = 1000199001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES:
    VkStructureType = 1000221000;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO: VkStructureType =
    1000246000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES:
    VkStructureType = 1000130000;
pub const VkStructureType_VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO: VkStructureType =
    1000130001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES:
    VkStructureType = 1000211000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES:
    VkStructureType = 1000108000;
pub const VkStructureType_VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO: VkStructureType =
    1000108001;
pub const VkStructureType_VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO: VkStructureType =
    1000108002;
pub const VkStructureType_VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO: VkStructureType =
    1000108003;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES : VkStructureType = 1000253000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES : VkStructureType = 1000175000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES : VkStructureType = 1000241000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT: VkStructureType =
    1000241001;
pub const VkStructureType_VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT: VkStructureType =
    1000241002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES:
    VkStructureType = 1000261000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES:
    VkStructureType = 1000207000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES:
    VkStructureType = 1000207001;
pub const VkStructureType_VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO: VkStructureType =
    1000207002;
pub const VkStructureType_VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO: VkStructureType =
    1000207003;
pub const VkStructureType_VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO: VkStructureType = 1000207004;
pub const VkStructureType_VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO: VkStructureType = 1000207005;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES:
    VkStructureType = 1000257000;
pub const VkStructureType_VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO: VkStructureType =
    1000244001;
pub const VkStructureType_VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO:
    VkStructureType = 1000257002;
pub const VkStructureType_VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO:
    VkStructureType = 1000257003;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO:
    VkStructureType = 1000257004;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES: VkStructureType =
    53;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES: VkStructureType =
    54;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO:
    VkStructureType = 1000192000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES:
    VkStructureType = 1000215000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES: VkStructureType =
    1000245000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES : VkStructureType = 1000276000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES: VkStructureType =
    1000295000;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO: VkStructureType =
    1000295001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO: VkStructureType =
    1000295002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES : VkStructureType = 1000297000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_MEMORY_BARRIER_2: VkStructureType = 1000314000;
pub const VkStructureType_VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2: VkStructureType = 1000314001;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2: VkStructureType = 1000314002;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEPENDENCY_INFO: VkStructureType = 1000314003;
pub const VkStructureType_VK_STRUCTURE_TYPE_SUBMIT_INFO_2: VkStructureType = 1000314004;
pub const VkStructureType_VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO: VkStructureType = 1000314005;
pub const VkStructureType_VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO: VkStructureType =
    1000314006;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES:
    VkStructureType = 1000314007;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES : VkStructureType = 1000325000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES:
    VkStructureType = 1000335000;
pub const VkStructureType_VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2: VkStructureType = 1000337000;
pub const VkStructureType_VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2: VkStructureType = 1000337001;
pub const VkStructureType_VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2: VkStructureType =
    1000337002;
pub const VkStructureType_VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2: VkStructureType =
    1000337003;
pub const VkStructureType_VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2: VkStructureType = 1000337004;
pub const VkStructureType_VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2: VkStructureType = 1000337005;
pub const VkStructureType_VK_STRUCTURE_TYPE_BUFFER_COPY_2: VkStructureType = 1000337006;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_COPY_2: VkStructureType = 1000337007;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_BLIT_2: VkStructureType = 1000337008;
pub const VkStructureType_VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2: VkStructureType = 1000337009;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2: VkStructureType = 1000337010;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES:
    VkStructureType = 1000225000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO : VkStructureType = 1000225001 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES:
    VkStructureType = 1000225002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES:
    VkStructureType = 1000138000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES:
    VkStructureType = 1000138001;
pub const VkStructureType_VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK:
    VkStructureType = 1000138002;
pub const VkStructureType_VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO:
    VkStructureType = 1000138003;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES : VkStructureType = 1000066000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_RENDERING_INFO: VkStructureType = 1000044000;
pub const VkStructureType_VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO: VkStructureType = 1000044001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO: VkStructureType =
    1000044002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES:
    VkStructureType = 1000044003;
pub const VkStructureType_VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO:
    VkStructureType = 1000044004;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES:
    VkStructureType = 1000280000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES : VkStructureType = 1000280001 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES:
    VkStructureType = 1000281001;
pub const VkStructureType_VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3: VkStructureType = 1000360000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES:
    VkStructureType = 1000413000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES:
    VkStructureType = 1000413001;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS: VkStructureType =
    1000413002;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS: VkStructureType =
    1000413003;
pub const VkStructureType_VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR: VkStructureType = 1000001000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PRESENT_INFO_KHR: VkStructureType = 1000001001;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR: VkStructureType =
    1000060007;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR: VkStructureType =
    1000060008;
pub const VkStructureType_VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR: VkStructureType =
    1000060009;
pub const VkStructureType_VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR: VkStructureType =
    1000060010;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR: VkStructureType =
    1000060011;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR:
    VkStructureType = 1000060012;
pub const VkStructureType_VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR: VkStructureType =
    1000002000;
pub const VkStructureType_VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR: VkStructureType =
    1000002001;
pub const VkStructureType_VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR: VkStructureType = 1000003000;
pub const VkStructureType_VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR: VkStructureType =
    1000004000;
pub const VkStructureType_VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR: VkStructureType =
    1000005000;
pub const VkStructureType_VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR: VkStructureType =
    1000006000;
pub const VkStructureType_VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR: VkStructureType =
    1000008000;
pub const VkStructureType_VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR: VkStructureType =
    1000009000;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT: VkStructureType =
    1000011000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD:
    VkStructureType = 1000018000;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT: VkStructureType =
    1000022000;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT: VkStructureType =
    1000022001;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT: VkStructureType =
    1000022002;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV:
    VkStructureType = 1000026000;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV:
    VkStructureType = 1000026001;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV:
    VkStructureType = 1000026002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT:
    VkStructureType = 1000028000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT:
    VkStructureType = 1000028001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT:
    VkStructureType = 1000028002;
pub const VkStructureType_VK_STRUCTURE_TYPE_CU_MODULE_CREATE_INFO_NVX: VkStructureType = 1000029000;
pub const VkStructureType_VK_STRUCTURE_TYPE_CU_FUNCTION_CREATE_INFO_NVX: VkStructureType =
    1000029001;
pub const VkStructureType_VK_STRUCTURE_TYPE_CU_LAUNCH_INFO_NVX: VkStructureType = 1000029002;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX: VkStructureType =
    1000030000;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_VIEW_ADDRESS_PROPERTIES_NVX: VkStructureType =
    1000030001;
pub const VkStructureType_VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD:
    VkStructureType = 1000041000;
pub const VkStructureType_VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR:
    VkStructureType = 1000044006;
pub const VkStructureType_VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT:
    VkStructureType = 1000044007;
pub const VkStructureType_VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD: VkStructureType =
    1000044008;
pub const VkStructureType_VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX:
    VkStructureType = 1000044009;
pub const VkStructureType_VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP:
    VkStructureType = 1000049000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV:
    VkStructureType = 1000050000;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV: VkStructureType =
    1000056000;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV: VkStructureType =
    1000056001;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV: VkStructureType =
    1000057000;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV: VkStructureType =
    1000057001;
pub const VkStructureType_VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV:
    VkStructureType = 1000058000;
pub const VkStructureType_VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT: VkStructureType = 1000061000;
pub const VkStructureType_VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN: VkStructureType = 1000062000;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT: VkStructureType =
    1000067000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT:
    VkStructureType = 1000067001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO_EXT: VkStructureType =
    1000068000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES_EXT:
    VkStructureType = 1000068001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES_EXT:
    VkStructureType = 1000068002;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR: VkStructureType =
    1000073000;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR: VkStructureType =
    1000073001;
pub const VkStructureType_VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR: VkStructureType =
    1000073002;
pub const VkStructureType_VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR: VkStructureType =
    1000073003;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR: VkStructureType = 1000074000;
pub const VkStructureType_VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR: VkStructureType = 1000074001;
pub const VkStructureType_VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR: VkStructureType = 1000074002;
pub const VkStructureType_VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR:
    VkStructureType = 1000075000;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR:
    VkStructureType = 1000078000;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR:
    VkStructureType = 1000078001;
pub const VkStructureType_VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR: VkStructureType =
    1000078002;
pub const VkStructureType_VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR: VkStructureType =
    1000078003;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR: VkStructureType =
    1000079000;
pub const VkStructureType_VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR: VkStructureType = 1000079001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR:
    VkStructureType = 1000080000;
pub const VkStructureType_VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT : VkStructureType = 1000081000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT:
    VkStructureType = 1000081001;
pub const VkStructureType_VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT: VkStructureType =
    1000081002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR: VkStructureType = 1000084000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV:
    VkStructureType = 1000087000;
pub const VkStructureType_VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT: VkStructureType =
    1000090000;
pub const VkStructureType_VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT: VkStructureType = 1000091000;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT: VkStructureType = 1000091001;
pub const VkStructureType_VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT: VkStructureType = 1000091002;
pub const VkStructureType_VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT: VkStructureType =
    1000091003;
pub const VkStructureType_VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE: VkStructureType = 1000092000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX : VkStructureType = 1000097000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV:
    VkStructureType = 1000098000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT:
    VkStructureType = 1000099000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT:
    VkStructureType = 1000099001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT : VkStructureType = 1000101000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT : VkStructureType = 1000101001 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT:
    VkStructureType = 1000102000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT : VkStructureType = 1000102001 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_HDR_METADATA_EXT: VkStructureType = 1000105000;
pub const VkStructureType_VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR:
    VkStructureType = 1000111000;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR: VkStructureType =
    1000114000;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR: VkStructureType =
    1000114001;
pub const VkStructureType_VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR: VkStructureType =
    1000114002;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR: VkStructureType = 1000115000;
pub const VkStructureType_VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR: VkStructureType = 1000115001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR:
    VkStructureType = 1000116000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR:
    VkStructureType = 1000116001;
pub const VkStructureType_VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR:
    VkStructureType = 1000116002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR: VkStructureType =
    1000116003;
pub const VkStructureType_VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR: VkStructureType =
    1000116004;
pub const VkStructureType_VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR: VkStructureType = 1000116005;
pub const VkStructureType_VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR: VkStructureType =
    1000116006;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR: VkStructureType =
    1000119000;
pub const VkStructureType_VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR: VkStructureType =
    1000119001;
pub const VkStructureType_VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR: VkStructureType = 1000119002;
pub const VkStructureType_VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR: VkStructureType = 1000121000;
pub const VkStructureType_VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR: VkStructureType =
    1000121001;
pub const VkStructureType_VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR: VkStructureType =
    1000121002;
pub const VkStructureType_VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR: VkStructureType = 1000121003;
pub const VkStructureType_VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR: VkStructureType =
    1000121004;
pub const VkStructureType_VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK: VkStructureType =
    1000122000;
pub const VkStructureType_VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK: VkStructureType =
    1000123000;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT: VkStructureType =
    1000128000;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT: VkStructureType =
    1000128001;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT: VkStructureType = 1000128002;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT:
    VkStructureType = 1000128003;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT: VkStructureType =
    1000128004;
pub const VkStructureType_VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID: VkStructureType =
    1000129000;
pub const VkStructureType_VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID:
    VkStructureType = 1000129001;
pub const VkStructureType_VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID:
    VkStructureType = 1000129002;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID:
    VkStructureType = 1000129003;
pub const VkStructureType_VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID:
    VkStructureType = 1000129004;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID: VkStructureType = 1000129005;
pub const VkStructureType_VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_2_ANDROID:
    VkStructureType = 1000129006;
pub const VkStructureType_VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT: VkStructureType = 1000143000;
pub const VkStructureType_VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT:
    VkStructureType = 1000143001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT:
    VkStructureType = 1000143002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT:
    VkStructureType = 1000143003;
pub const VkStructureType_VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT: VkStructureType =
    1000143004;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT : VkStructureType = 1000148000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT : VkStructureType = 1000148001 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT:
    VkStructureType = 1000148002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV:
    VkStructureType = 1000149000;
pub const VkStructureType_VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR:
    VkStructureType = 1000150007;
pub const VkStructureType_VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR:
    VkStructureType = 1000150000;
pub const VkStructureType_VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR:
    VkStructureType = 1000150002;
pub const VkStructureType_VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR:
    VkStructureType = 1000150003;
pub const VkStructureType_VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR:
    VkStructureType = 1000150004;
pub const VkStructureType_VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR:
    VkStructureType = 1000150005;
pub const VkStructureType_VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR: VkStructureType =
    1000150006;
pub const VkStructureType_VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR:
    VkStructureType = 1000150009;
pub const VkStructureType_VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR: VkStructureType =
    1000150010;
pub const VkStructureType_VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR:
    VkStructureType = 1000150011;
pub const VkStructureType_VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR:
    VkStructureType = 1000150012;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR:
    VkStructureType = 1000150013;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR : VkStructureType = 1000150014 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR:
    VkStructureType = 1000150017;
pub const VkStructureType_VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR:
    VkStructureType = 1000150020;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR:
    VkStructureType = 1000347000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR:
    VkStructureType = 1000347001;
pub const VkStructureType_VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR: VkStructureType =
    1000150015;
pub const VkStructureType_VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR:
    VkStructureType = 1000150016;
pub const VkStructureType_VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR:
    VkStructureType = 1000150018;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR:
    VkStructureType = 1000348013;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV:
    VkStructureType = 1000152000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV:
    VkStructureType = 1000154000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV:
    VkStructureType = 1000154001;
pub const VkStructureType_VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT:
    VkStructureType = 1000158000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT:
    VkStructureType = 1000158002;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT:
    VkStructureType = 1000158003;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT:
    VkStructureType = 1000158004;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT:
    VkStructureType = 1000158005;
pub const VkStructureType_VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT:
    VkStructureType = 1000158006;
pub const VkStructureType_VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT: VkStructureType =
    1000160000;
pub const VkStructureType_VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT:
    VkStructureType = 1000160001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV : VkStructureType = 1000164000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV:
    VkStructureType = 1000164001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV:
    VkStructureType = 1000164002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV : VkStructureType = 1000164005 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV: VkStructureType =
    1000165000;
pub const VkStructureType_VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV: VkStructureType =
    1000165001;
pub const VkStructureType_VK_STRUCTURE_TYPE_GEOMETRY_NV: VkStructureType = 1000165003;
pub const VkStructureType_VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV: VkStructureType = 1000165004;
pub const VkStructureType_VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV: VkStructureType = 1000165005;
pub const VkStructureType_VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV:
    VkStructureType = 1000165006;
pub const VkStructureType_VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV:
    VkStructureType = 1000165007;
pub const VkStructureType_VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV:
    VkStructureType = 1000165008;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV:
    VkStructureType = 1000165009;
pub const VkStructureType_VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV:
    VkStructureType = 1000165011;
pub const VkStructureType_VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV: VkStructureType =
    1000165012;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV : VkStructureType = 1000166000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV : VkStructureType = 1000166001 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT:
    VkStructureType = 1000170000;
pub const VkStructureType_VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT:
    VkStructureType = 1000170001;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT: VkStructureType =
    1000178000;
pub const VkStructureType_VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT: VkStructureType =
    1000178001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT:
    VkStructureType = 1000178002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR:
    VkStructureType = 1000181000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD:
    VkStructureType = 1000183000;
pub const VkStructureType_VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT: VkStructureType =
    1000184000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD:
    VkStructureType = 1000185000;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_KHR:
    VkStructureType = 1000174000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR:
    VkStructureType = 1000388000;
pub const VkStructureType_VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_KHR:
    VkStructureType = 1000388001;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD:
    VkStructureType = 1000189000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT : VkStructureType = 1000190000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT:
    VkStructureType = 1000190001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT : VkStructureType = 1000190002 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP: VkStructureType = 1000191000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV : VkStructureType = 1000201000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV:
    VkStructureType = 1000202000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV:
    VkStructureType = 1000202001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV:
    VkStructureType = 1000204000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV : VkStructureType = 1000205000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV:
    VkStructureType = 1000205002;
pub const VkStructureType_VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV: VkStructureType = 1000206000;
pub const VkStructureType_VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV: VkStructureType =
    1000206001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL : VkStructureType = 1000209000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL:
    VkStructureType = 1000210000;
pub const VkStructureType_VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL: VkStructureType =
    1000210001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL: VkStructureType =
    1000210002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL: VkStructureType =
    1000210003;
pub const VkStructureType_VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL: VkStructureType =
    1000210004;
pub const VkStructureType_VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL:
    VkStructureType = 1000210005;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT:
    VkStructureType = 1000212000;
pub const VkStructureType_VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD:
    VkStructureType = 1000213000;
pub const VkStructureType_VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD:
    VkStructureType = 1000213001;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA: VkStructureType =
    1000214000;
pub const VkStructureType_VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT: VkStructureType =
    1000217000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT:
    VkStructureType = 1000218000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT:
    VkStructureType = 1000218001;
pub const VkStructureType_VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT:
    VkStructureType = 1000218002;
pub const VkStructureType_VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR:
    VkStructureType = 1000226000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR:
    VkStructureType = 1000226001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR:
    VkStructureType = 1000226002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR:
    VkStructureType = 1000226003;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR:
    VkStructureType = 1000226004;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD:
    VkStructureType = 1000227000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD:
    VkStructureType = 1000229000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT : VkStructureType = 1000234000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT:
    VkStructureType = 1000237000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT:
    VkStructureType = 1000238000;
pub const VkStructureType_VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT: VkStructureType =
    1000238001;
pub const VkStructureType_VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR: VkStructureType =
    1000239000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV : VkStructureType = 1000240000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT:
    VkStructureType = 1000244000;
pub const VkStructureType_VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT: VkStructureType =
    1000244002;
pub const VkStructureType_VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT: VkStructureType = 1000247000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR:
    VkStructureType = 1000248000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV:
    VkStructureType = 1000249000;
pub const VkStructureType_VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV: VkStructureType =
    1000249001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV:
    VkStructureType = 1000249002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV:
    VkStructureType = 1000250000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV:
    VkStructureType = 1000250001;
pub const VkStructureType_VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV:
    VkStructureType = 1000250002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT : VkStructureType = 1000251000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT:
    VkStructureType = 1000252000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT:
    VkStructureType = 1000254000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT : VkStructureType = 1000254001 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT:
    VkStructureType = 1000254002;
pub const VkStructureType_VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT:
    VkStructureType = 1000255000;
pub const VkStructureType_VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT:
    VkStructureType = 1000255002;
pub const VkStructureType_VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT:
    VkStructureType = 1000255001;
pub const VkStructureType_VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT: VkStructureType =
    1000256000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT:
    VkStructureType = 1000259000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT:
    VkStructureType = 1000259001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT:
    VkStructureType = 1000259002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT:
    VkStructureType = 1000260000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT:
    VkStructureType = 1000265000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT:
    VkStructureType = 1000267000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR : VkStructureType = 1000269000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR: VkStructureType = 1000269001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR: VkStructureType =
    1000269002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR: VkStructureType =
    1000269003;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR: VkStructureType =
    1000269004;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR:
    VkStructureType = 1000269005;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT:
    VkStructureType = 1000273000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV : VkStructureType = 1000277000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV: VkStructureType =
    1000277001;
pub const VkStructureType_VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV:
    VkStructureType = 1000277002;
pub const VkStructureType_VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV: VkStructureType =
    1000277003;
pub const VkStructureType_VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV:
    VkStructureType = 1000277004;
pub const VkStructureType_VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV: VkStructureType =
    1000277005;
pub const VkStructureType_VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV:
    VkStructureType = 1000277006;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV : VkStructureType = 1000277007 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV : VkStructureType = 1000278000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV:
    VkStructureType = 1000278001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT:
    VkStructureType = 1000281000;
pub const VkStructureType_VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM : VkStructureType = 1000282000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM: VkStructureType =
    1000282001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT:
    VkStructureType = 1000284000;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT:
    VkStructureType = 1000284001;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT:
    VkStructureType = 1000284002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT:
    VkStructureType = 1000286000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT:
    VkStructureType = 1000286001;
pub const VkStructureType_VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT:
    VkStructureType = 1000287000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT:
    VkStructureType = 1000287001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT:
    VkStructureType = 1000287002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR: VkStructureType =
    1000290000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PRESENT_ID_KHR: VkStructureType = 1000294000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR:
    VkStructureType = 1000294001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV:
    VkStructureType = 1000300000;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV:
    VkStructureType = 1000300001;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT: VkStructureType =
    1000311000;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECTS_INFO_EXT: VkStructureType =
    1000311001;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXPORT_METAL_DEVICE_INFO_EXT: VkStructureType =
    1000311002;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXPORT_METAL_COMMAND_QUEUE_INFO_EXT: VkStructureType =
    1000311003;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXPORT_METAL_BUFFER_INFO_EXT: VkStructureType =
    1000311004;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMPORT_METAL_BUFFER_INFO_EXT: VkStructureType =
    1000311005;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXPORT_METAL_TEXTURE_INFO_EXT: VkStructureType =
    1000311006;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMPORT_METAL_TEXTURE_INFO_EXT: VkStructureType =
    1000311007;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXPORT_METAL_IO_SURFACE_INFO_EXT: VkStructureType =
    1000311008;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMPORT_METAL_IO_SURFACE_INFO_EXT: VkStructureType =
    1000311009;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXPORT_METAL_SHARED_EVENT_INFO_EXT: VkStructureType =
    1000311010;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMPORT_METAL_SHARED_EVENT_INFO_EXT: VkStructureType =
    1000311011;
pub const VkStructureType_VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV:
    VkStructureType = 1000314008;
pub const VkStructureType_VK_STRUCTURE_TYPE_CHECKPOINT_DATA_2_NV: VkStructureType = 1000314009;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT : VkStructureType = 1000320000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT : VkStructureType = 1000320001 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT:
    VkStructureType = 1000320002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD : VkStructureType = 1000321000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR : VkStructureType = 1000203000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR : VkStructureType = 1000322000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR : VkStructureType = 1000323000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV : VkStructureType = 1000326000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV : VkStructureType = 1000326001 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV : VkStructureType = 1000326002 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV : VkStructureType = 1000327000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV:
    VkStructureType = 1000327001;
pub const VkStructureType_VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV: VkStructureType =
    1000327002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT:
    VkStructureType = 1000328000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT:
    VkStructureType = 1000328001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT : VkStructureType = 1000330000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT:
    VkStructureType = 1000332000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT : VkStructureType = 1000332001 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM: VkStructureType =
    1000333000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR : VkStructureType = 1000336000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT : VkStructureType = 1000338000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT: VkStructureType =
    1000338001;
pub const VkStructureType_VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2_EXT: VkStructureType = 1000338002;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2_EXT: VkStructureType = 1000338003;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT: VkStructureType =
    1000338004;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT : VkStructureType = 1000339000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT:
    VkStructureType = 1000340000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT:
    VkStructureType = 1000344000;
pub const VkStructureType_VK_STRUCTURE_TYPE_DIRECTFB_SURFACE_CREATE_INFO_EXT: VkStructureType =
    1000346000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_VALVE : VkStructureType = 1000351000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_VALVE:
    VkStructureType = 1000351002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT : VkStructureType = 1000352000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT:
    VkStructureType = 1000352001;
pub const VkStructureType_VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT:
    VkStructureType = 1000352002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT: VkStructureType =
    1000353000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT:
    VkStructureType = 1000355000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT:
    VkStructureType = 1000355001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT : VkStructureType = 1000356000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA:
    VkStructureType = 1000364000;
pub const VkStructureType_VK_STRUCTURE_TYPE_MEMORY_ZIRCON_HANDLE_PROPERTIES_FUCHSIA:
    VkStructureType = 1000364001;
pub const VkStructureType_VK_STRUCTURE_TYPE_MEMORY_GET_ZIRCON_HANDLE_INFO_FUCHSIA: VkStructureType =
    1000364002;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_ZIRCON_HANDLE_INFO_FUCHSIA:
    VkStructureType = 1000365000;
pub const VkStructureType_VK_STRUCTURE_TYPE_SEMAPHORE_GET_ZIRCON_HANDLE_INFO_FUCHSIA:
    VkStructureType = 1000365001;
pub const VkStructureType_VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CREATE_INFO_FUCHSIA: VkStructureType =
    1000366000;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMPORT_MEMORY_BUFFER_COLLECTION_FUCHSIA:
    VkStructureType = 1000366001;
pub const VkStructureType_VK_STRUCTURE_TYPE_BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA:
    VkStructureType = 1000366002;
pub const VkStructureType_VK_STRUCTURE_TYPE_BUFFER_COLLECTION_PROPERTIES_FUCHSIA: VkStructureType =
    1000366003;
pub const VkStructureType_VK_STRUCTURE_TYPE_BUFFER_CONSTRAINTS_INFO_FUCHSIA: VkStructureType =
    1000366004;
pub const VkStructureType_VK_STRUCTURE_TYPE_BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA:
    VkStructureType = 1000366005;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_CONSTRAINTS_INFO_FUCHSIA: VkStructureType =
    1000366006;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_FORMAT_CONSTRAINTS_INFO_FUCHSIA: VkStructureType =
    1000366007;
pub const VkStructureType_VK_STRUCTURE_TYPE_SYSMEM_COLOR_SPACE_FUCHSIA: VkStructureType =
    1000366008;
pub const VkStructureType_VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CONSTRAINTS_INFO_FUCHSIA:
    VkStructureType = 1000366009;
pub const VkStructureType_VK_STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI:
    VkStructureType = 1000369000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI:
    VkStructureType = 1000369001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI:
    VkStructureType = 1000369002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI:
    VkStructureType = 1000370000;
pub const VkStructureType_VK_STRUCTURE_TYPE_MEMORY_GET_REMOTE_ADDRESS_INFO_NV: VkStructureType =
    1000371000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV:
    VkStructureType = 1000371001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_PROPERTIES_IDENTIFIER_EXT: VkStructureType =
    1000372000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT:
    VkStructureType = 1000372001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT : VkStructureType = 1000376000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT: VkStructureType =
    1000376001;
pub const VkStructureType_VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT:
    VkStructureType = 1000376002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT : VkStructureType = 1000377000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_SCREEN_SURFACE_CREATE_INFO_QNX: VkStructureType =
    1000378000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT:
    VkStructureType = 1000381000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT: VkStructureType =
    1000381001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT : VkStructureType = 1000382000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR : VkStructureType = 1000386000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT:
    VkStructureType = 1000391000;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT: VkStructureType =
    1000391001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT:
    VkStructureType = 1000392000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT:
    VkStructureType = 1000392001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT:
    VkStructureType = 1000393000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT:
    VkStructureType = 1000411000;
pub const VkStructureType_VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT : VkStructureType = 1000411001 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT : VkStructureType = 1000412000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE : VkStructureType = 1000420000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_DESCRIPTOR_SET_BINDING_REFERENCE_VALVE:
    VkStructureType = 1000420001;
pub const VkStructureType_VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE:
    VkStructureType = 1000420002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_EXT:
    VkStructureType = 1000421000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT:
    VkStructureType = 1000422000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_QCOM : VkStructureType = 1000425000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_QCOM : VkStructureType = 1000425001 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_SUBPASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_QCOM:
    VkStructureType = 1000425002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV:
    VkStructureType = 1000430000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT : VkStructureType = 1000437000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM:
    VkStructureType = 1000440000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM:
    VkStructureType = 1000440001;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_QCOM:
    VkStructureType = 1000440002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT:
    VkStructureType = 1000458000;
pub const VkStructureType_VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT: VkStructureType =
    1000458001;
pub const VkStructureType_VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT:
    VkStructureType = 1000458002;
pub const VkStructureType_VK_STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT:
    VkStructureType = 1000458003;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT : VkStructureType = 1000462000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT : VkStructureType = 1000462001 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT : VkStructureType = 1000462002 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_SHADER_MODULE_IDENTIFIER_EXT: VkStructureType =
    1000462003;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT : VkStructureType = 1000342000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT:
    VkStructureType = 1000465000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM:
    VkStructureType = 1000484000;
pub const VkStructureType_VK_STRUCTURE_TYPE_TILE_PROPERTIES_QCOM: VkStructureType = 1000484001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_AMIGO_PROFILING_FEATURES_SEC:
    VkStructureType = 1000485000;
pub const VkStructureType_VK_STRUCTURE_TYPE_AMIGO_PROFILING_SUBMIT_INFO_SEC: VkStructureType =
    1000485001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES:
    VkStructureType = 1000120000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES:
    VkStructureType = 1000063000;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT: VkStructureType =
    1000011000;
pub const VkStructureType_VK_STRUCTURE_TYPE_RENDERING_INFO_KHR: VkStructureType = 1000044000;
pub const VkStructureType_VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO_KHR: VkStructureType =
    1000044001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO_KHR: VkStructureType =
    1000044002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES_KHR:
    VkStructureType = 1000044003;
pub const VkStructureType_VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO_KHR:
    VkStructureType = 1000044004;
pub const VkStructureType_VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_NV: VkStructureType =
    1000044008;
pub const VkStructureType_VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO_KHR: VkStructureType =
    1000053000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHR:
    VkStructureType = 1000053001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHR:
    VkStructureType = 1000053002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2_KHR: VkStructureType =
    1000059000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2_KHR: VkStructureType =
    1000059001;
pub const VkStructureType_VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2_KHR: VkStructureType = 1000059002;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2_KHR: VkStructureType =
    1000059003;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR:
    VkStructureType = 1000059004;
pub const VkStructureType_VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2_KHR: VkStructureType =
    1000059005;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR:
    VkStructureType = 1000059006;
pub const VkStructureType_VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR: VkStructureType =
    1000059007;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR:
    VkStructureType = 1000059008;
pub const VkStructureType_VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHR: VkStructureType =
    1000060000;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHR:
    VkStructureType = 1000060003;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHR:
    VkStructureType = 1000060004;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO_KHR: VkStructureType =
    1000060005;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO_KHR: VkStructureType =
    1000060006;
pub const VkStructureType_VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO_KHR:
    VkStructureType = 1000060013;
pub const VkStructureType_VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO_KHR:
    VkStructureType = 1000060014;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT : VkStructureType = 1000066000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES_KHR: VkStructureType =
    1000070000;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO_KHR: VkStructureType =
    1000070001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR:
    VkStructureType = 1000071000;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR: VkStructureType =
    1000071001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR:
    VkStructureType = 1000071002;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES_KHR: VkStructureType =
    1000071003;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR: VkStructureType =
    1000071004;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR:
    VkStructureType = 1000072000;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR: VkStructureType =
    1000072001;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR: VkStructureType =
    1000072002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR:
    VkStructureType = 1000076000;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES_KHR: VkStructureType =
    1000076001;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO_KHR: VkStructureType =
    1000077000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES_KHR:
    VkStructureType = 1000082000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT16_INT8_FEATURES_KHR:
    VkStructureType = 1000082000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES_KHR:
    VkStructureType = 1000083000;
pub const VkStructureType_VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR:
    VkStructureType = 1000085000;
pub const VkStructureType_VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES2_EXT: VkStructureType = 1000090000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES_KHR:
    VkStructureType = 1000108000;
pub const VkStructureType_VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO_KHR:
    VkStructureType = 1000108001;
pub const VkStructureType_VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO_KHR: VkStructureType =
    1000108002;
pub const VkStructureType_VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO_KHR: VkStructureType =
    1000108003;
pub const VkStructureType_VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2_KHR: VkStructureType =
    1000109000;
pub const VkStructureType_VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2_KHR: VkStructureType =
    1000109001;
pub const VkStructureType_VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2_KHR: VkStructureType = 1000109002;
pub const VkStructureType_VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2_KHR: VkStructureType = 1000109003;
pub const VkStructureType_VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2_KHR: VkStructureType =
    1000109004;
pub const VkStructureType_VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO_KHR: VkStructureType = 1000109005;
pub const VkStructureType_VK_STRUCTURE_TYPE_SUBPASS_END_INFO_KHR: VkStructureType = 1000109006;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR:
    VkStructureType = 1000112000;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES_KHR: VkStructureType =
    1000112001;
pub const VkStructureType_VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO_KHR: VkStructureType =
    1000113000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES_KHR:
    VkStructureType = 1000117000;
pub const VkStructureType_VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO_KHR:
    VkStructureType = 1000117001;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO_KHR: VkStructureType =
    1000117002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO_KHR : VkStructureType = 1000117003 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES_KHR:
    VkStructureType = 1000120000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES_KHR:
    VkStructureType = 1000120000;
pub const VkStructureType_VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR: VkStructureType =
    1000127000;
pub const VkStructureType_VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_KHR: VkStructureType =
    1000127001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT:
    VkStructureType = 1000130000;
pub const VkStructureType_VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT:
    VkStructureType = 1000130001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT:
    VkStructureType = 1000138000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT:
    VkStructureType = 1000138001;
pub const VkStructureType_VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT:
    VkStructureType = 1000138002;
pub const VkStructureType_VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT:
    VkStructureType = 1000138003;
pub const VkStructureType_VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR: VkStructureType =
    1000146000;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR: VkStructureType =
    1000146001;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR:
    VkStructureType = 1000146002;
pub const VkStructureType_VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR: VkStructureType = 1000146003;
pub const VkStructureType_VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR:
    VkStructureType = 1000146004;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR: VkStructureType =
    1000147000;
pub const VkStructureType_VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO_KHR:
    VkStructureType = 1000156000;
pub const VkStructureType_VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO_KHR: VkStructureType =
    1000156001;
pub const VkStructureType_VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO_KHR: VkStructureType =
    1000156002;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO_KHR:
    VkStructureType = 1000156003;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES_KHR : VkStructureType = 1000156004 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES_KHR:
    VkStructureType = 1000156005;
pub const VkStructureType_VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHR: VkStructureType =
    1000157000;
pub const VkStructureType_VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHR: VkStructureType =
    1000157001;
pub const VkStructureType_VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT:
    VkStructureType = 1000161000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT:
    VkStructureType = 1000161001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT:
    VkStructureType = 1000161002;
pub const VkStructureType_VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT : VkStructureType = 1000161003 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT : VkStructureType = 1000161004 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES_KHR:
    VkStructureType = 1000168000;
pub const VkStructureType_VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT_KHR: VkStructureType =
    1000168001;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT:
    VkStructureType = 1000174000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES_KHR : VkStructureType = 1000175000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR:
    VkStructureType = 1000177000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR:
    VkStructureType = 1000180000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT:
    VkStructureType = 1000192000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR: VkStructureType =
    1000196000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES_KHR:
    VkStructureType = 1000197000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES_KHR:
    VkStructureType = 1000199000;
pub const VkStructureType_VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE_KHR:
    VkStructureType = 1000199001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV : VkStructureType = 1000203000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES_KHR:
    VkStructureType = 1000207000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES_KHR:
    VkStructureType = 1000207001;
pub const VkStructureType_VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO_KHR: VkStructureType =
    1000207002;
pub const VkStructureType_VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO_KHR: VkStructureType =
    1000207003;
pub const VkStructureType_VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO_KHR: VkStructureType = 1000207004;
pub const VkStructureType_VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO_KHR: VkStructureType = 1000207005;
pub const VkStructureType_VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO_INTEL: VkStructureType =
    1000210000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR:
    VkStructureType = 1000211000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES_KHR : VkStructureType = 1000215000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES_EXT:
    VkStructureType = 1000221000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT:
    VkStructureType = 1000225000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT : VkStructureType = 1000225001 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT:
    VkStructureType = 1000225002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES_KHR : VkStructureType = 1000241000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT_KHR:
    VkStructureType = 1000241001;
pub const VkStructureType_VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT_KHR:
    VkStructureType = 1000241002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_ADDRESS_FEATURES_EXT:
    VkStructureType = 1000244000;
pub const VkStructureType_VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_EXT: VkStructureType =
    1000244001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES_EXT: VkStructureType =
    1000245000;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO_EXT: VkStructureType =
    1000246000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES_KHR : VkStructureType = 1000253000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_KHR:
    VkStructureType = 1000257000;
pub const VkStructureType_VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_KHR: VkStructureType =
    1000244001;
pub const VkStructureType_VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO_KHR:
    VkStructureType = 1000257002;
pub const VkStructureType_VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO_KHR:
    VkStructureType = 1000257003;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO_KHR:
    VkStructureType = 1000257004;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES_EXT:
    VkStructureType = 1000261000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT : VkStructureType = 1000276000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES_KHR : VkStructureType = 1000280000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES_KHR : VkStructureType = 1000280001 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT : VkStructureType = 1000281001 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES_EXT:
    VkStructureType = 1000295000;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO_EXT: VkStructureType =
    1000295001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO_EXT: VkStructureType =
    1000295002;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES_EXT : VkStructureType = 1000297000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_MEMORY_BARRIER_2_KHR: VkStructureType = 1000314000;
pub const VkStructureType_VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2_KHR: VkStructureType =
    1000314001;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2_KHR: VkStructureType =
    1000314002;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEPENDENCY_INFO_KHR: VkStructureType = 1000314003;
pub const VkStructureType_VK_STRUCTURE_TYPE_SUBMIT_INFO_2_KHR: VkStructureType = 1000314004;
pub const VkStructureType_VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO_KHR: VkStructureType = 1000314005;
pub const VkStructureType_VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO_KHR: VkStructureType =
    1000314006;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES_KHR:
    VkStructureType = 1000314007;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES_KHR : VkStructureType = 1000325000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES_EXT:
    VkStructureType = 1000335000;
pub const VkStructureType_VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2_KHR: VkStructureType = 1000337000;
pub const VkStructureType_VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2_KHR: VkStructureType = 1000337001;
pub const VkStructureType_VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2_KHR: VkStructureType =
    1000337002;
pub const VkStructureType_VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2_KHR: VkStructureType =
    1000337003;
pub const VkStructureType_VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2_KHR: VkStructureType = 1000337004;
pub const VkStructureType_VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2_KHR: VkStructureType = 1000337005;
pub const VkStructureType_VK_STRUCTURE_TYPE_BUFFER_COPY_2_KHR: VkStructureType = 1000337006;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_COPY_2_KHR: VkStructureType = 1000337007;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_BLIT_2_KHR: VkStructureType = 1000337008;
pub const VkStructureType_VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2_KHR: VkStructureType = 1000337009;
pub const VkStructureType_VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2_KHR: VkStructureType = 1000337010;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_ARM : VkStructureType = 1000342000 ;
pub const VkStructureType_VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3_KHR: VkStructureType = 1000360000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PIPELINE_INFO_EXT: VkStructureType = 1000269001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_EXT:
    VkStructureType = 1000388000;
pub const VkStructureType_VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_EXT:
    VkStructureType = 1000388001;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES_KHR:
    VkStructureType = 1000413000;
pub const VkStructureType_VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES_KHR:
    VkStructureType = 1000413001;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS_KHR: VkStructureType =
    1000413002;
pub const VkStructureType_VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS_KHR: VkStructureType =
    1000413003;
pub const VkStructureType_VK_STRUCTURE_TYPE_MAX_ENUM: VkStructureType = 2147483647;
pub type VkStructureType = ::std::os::raw::c_uint;
pub const VkImageLayout_VK_IMAGE_LAYOUT_UNDEFINED: VkImageLayout = 0;
pub const VkImageLayout_VK_IMAGE_LAYOUT_GENERAL: VkImageLayout = 1;
pub const VkImageLayout_VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL: VkImageLayout = 2;
pub const VkImageLayout_VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL: VkImageLayout = 3;
pub const VkImageLayout_VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL: VkImageLayout = 4;
pub const VkImageLayout_VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL: VkImageLayout = 5;
pub const VkImageLayout_VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL: VkImageLayout = 6;
pub const VkImageLayout_VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL: VkImageLayout = 7;
pub const VkImageLayout_VK_IMAGE_LAYOUT_PREINITIALIZED: VkImageLayout = 8;
pub const VkImageLayout_VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL: VkImageLayout =
    1000117000;
pub const VkImageLayout_VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL: VkImageLayout =
    1000117001;
pub const VkImageLayout_VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL: VkImageLayout = 1000241000;
pub const VkImageLayout_VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL: VkImageLayout = 1000241001;
pub const VkImageLayout_VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL: VkImageLayout = 1000241002;
pub const VkImageLayout_VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL: VkImageLayout = 1000241003;
pub const VkImageLayout_VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL: VkImageLayout = 1000314000;
pub const VkImageLayout_VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL: VkImageLayout = 1000314001;
pub const VkImageLayout_VK_IMAGE_LAYOUT_PRESENT_SRC_KHR: VkImageLayout = 1000001002;
pub const VkImageLayout_VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR: VkImageLayout = 1000111000;
pub const VkImageLayout_VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT: VkImageLayout =
    1000218000;
pub const VkImageLayout_VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR:
    VkImageLayout = 1000164003;
pub const VkImageLayout_VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT: VkImageLayout =
    1000339000;
pub const VkImageLayout_VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR:
    VkImageLayout = 1000117000;
pub const VkImageLayout_VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR:
    VkImageLayout = 1000117001;
pub const VkImageLayout_VK_IMAGE_LAYOUT_SHADING_RATE_OPTIMAL_NV: VkImageLayout = 1000164003;
pub const VkImageLayout_VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL_KHR: VkImageLayout = 1000241000;
pub const VkImageLayout_VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL_KHR: VkImageLayout = 1000241001;
pub const VkImageLayout_VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL_KHR: VkImageLayout = 1000241002;
pub const VkImageLayout_VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL_KHR: VkImageLayout = 1000241003;
pub const VkImageLayout_VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL_KHR: VkImageLayout = 1000314000;
pub const VkImageLayout_VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL_KHR: VkImageLayout = 1000314001;
pub const VkImageLayout_VK_IMAGE_LAYOUT_MAX_ENUM: VkImageLayout = 2147483647;
pub type VkImageLayout = ::std::os::raw::c_uint;
pub const VkSystemAllocationScope_VK_SYSTEM_ALLOCATION_SCOPE_COMMAND: VkSystemAllocationScope = 0;
pub const VkSystemAllocationScope_VK_SYSTEM_ALLOCATION_SCOPE_OBJECT: VkSystemAllocationScope = 1;
pub const VkSystemAllocationScope_VK_SYSTEM_ALLOCATION_SCOPE_CACHE: VkSystemAllocationScope = 2;
pub const VkSystemAllocationScope_VK_SYSTEM_ALLOCATION_SCOPE_DEVICE: VkSystemAllocationScope = 3;
pub const VkSystemAllocationScope_VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE: VkSystemAllocationScope = 4;
pub const VkSystemAllocationScope_VK_SYSTEM_ALLOCATION_SCOPE_MAX_ENUM: VkSystemAllocationScope =
    2147483647;
pub type VkSystemAllocationScope = ::std::os::raw::c_uint;
pub const VkInternalAllocationType_VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE:
    VkInternalAllocationType = 0;
pub const VkInternalAllocationType_VK_INTERNAL_ALLOCATION_TYPE_MAX_ENUM: VkInternalAllocationType =
    2147483647;
pub type VkInternalAllocationType = ::std::os::raw::c_uint;
pub const VkFormat_VK_FORMAT_UNDEFINED: VkFormat = 0;
pub const VkFormat_VK_FORMAT_R4G4_UNORM_PACK8: VkFormat = 1;
pub const VkFormat_VK_FORMAT_R4G4B4A4_UNORM_PACK16: VkFormat = 2;
pub const VkFormat_VK_FORMAT_B4G4R4A4_UNORM_PACK16: VkFormat = 3;
pub const VkFormat_VK_FORMAT_R5G6B5_UNORM_PACK16: VkFormat = 4;
pub const VkFormat_VK_FORMAT_B5G6R5_UNORM_PACK16: VkFormat = 5;
pub const VkFormat_VK_FORMAT_R5G5B5A1_UNORM_PACK16: VkFormat = 6;
pub const VkFormat_VK_FORMAT_B5G5R5A1_UNORM_PACK16: VkFormat = 7;
pub const VkFormat_VK_FORMAT_A1R5G5B5_UNORM_PACK16: VkFormat = 8;
pub const VkFormat_VK_FORMAT_R8_UNORM: VkFormat = 9;
pub const VkFormat_VK_FORMAT_R8_SNORM: VkFormat = 10;
pub const VkFormat_VK_FORMAT_R8_USCALED: VkFormat = 11;
pub const VkFormat_VK_FORMAT_R8_SSCALED: VkFormat = 12;
pub const VkFormat_VK_FORMAT_R8_UINT: VkFormat = 13;
pub const VkFormat_VK_FORMAT_R8_SINT: VkFormat = 14;
pub const VkFormat_VK_FORMAT_R8_SRGB: VkFormat = 15;
pub const VkFormat_VK_FORMAT_R8G8_UNORM: VkFormat = 16;
pub const VkFormat_VK_FORMAT_R8G8_SNORM: VkFormat = 17;
pub const VkFormat_VK_FORMAT_R8G8_USCALED: VkFormat = 18;
pub const VkFormat_VK_FORMAT_R8G8_SSCALED: VkFormat = 19;
pub const VkFormat_VK_FORMAT_R8G8_UINT: VkFormat = 20;
pub const VkFormat_VK_FORMAT_R8G8_SINT: VkFormat = 21;
pub const VkFormat_VK_FORMAT_R8G8_SRGB: VkFormat = 22;
pub const VkFormat_VK_FORMAT_R8G8B8_UNORM: VkFormat = 23;
pub const VkFormat_VK_FORMAT_R8G8B8_SNORM: VkFormat = 24;
pub const VkFormat_VK_FORMAT_R8G8B8_USCALED: VkFormat = 25;
pub const VkFormat_VK_FORMAT_R8G8B8_SSCALED: VkFormat = 26;
pub const VkFormat_VK_FORMAT_R8G8B8_UINT: VkFormat = 27;
pub const VkFormat_VK_FORMAT_R8G8B8_SINT: VkFormat = 28;
pub const VkFormat_VK_FORMAT_R8G8B8_SRGB: VkFormat = 29;
pub const VkFormat_VK_FORMAT_B8G8R8_UNORM: VkFormat = 30;
pub const VkFormat_VK_FORMAT_B8G8R8_SNORM: VkFormat = 31;
pub const VkFormat_VK_FORMAT_B8G8R8_USCALED: VkFormat = 32;
pub const VkFormat_VK_FORMAT_B8G8R8_SSCALED: VkFormat = 33;
pub const VkFormat_VK_FORMAT_B8G8R8_UINT: VkFormat = 34;
pub const VkFormat_VK_FORMAT_B8G8R8_SINT: VkFormat = 35;
pub const VkFormat_VK_FORMAT_B8G8R8_SRGB: VkFormat = 36;
pub const VkFormat_VK_FORMAT_R8G8B8A8_UNORM: VkFormat = 37;
pub const VkFormat_VK_FORMAT_R8G8B8A8_SNORM: VkFormat = 38;
pub const VkFormat_VK_FORMAT_R8G8B8A8_USCALED: VkFormat = 39;
pub const VkFormat_VK_FORMAT_R8G8B8A8_SSCALED: VkFormat = 40;
pub const VkFormat_VK_FORMAT_R8G8B8A8_UINT: VkFormat = 41;
pub const VkFormat_VK_FORMAT_R8G8B8A8_SINT: VkFormat = 42;
pub const VkFormat_VK_FORMAT_R8G8B8A8_SRGB: VkFormat = 43;
pub const VkFormat_VK_FORMAT_B8G8R8A8_UNORM: VkFormat = 44;
pub const VkFormat_VK_FORMAT_B8G8R8A8_SNORM: VkFormat = 45;
pub const VkFormat_VK_FORMAT_B8G8R8A8_USCALED: VkFormat = 46;
pub const VkFormat_VK_FORMAT_B8G8R8A8_SSCALED: VkFormat = 47;
pub const VkFormat_VK_FORMAT_B8G8R8A8_UINT: VkFormat = 48;
pub const VkFormat_VK_FORMAT_B8G8R8A8_SINT: VkFormat = 49;
pub const VkFormat_VK_FORMAT_B8G8R8A8_SRGB: VkFormat = 50;
pub const VkFormat_VK_FORMAT_A8B8G8R8_UNORM_PACK32: VkFormat = 51;
pub const VkFormat_VK_FORMAT_A8B8G8R8_SNORM_PACK32: VkFormat = 52;
pub const VkFormat_VK_FORMAT_A8B8G8R8_USCALED_PACK32: VkFormat = 53;
pub const VkFormat_VK_FORMAT_A8B8G8R8_SSCALED_PACK32: VkFormat = 54;
pub const VkFormat_VK_FORMAT_A8B8G8R8_UINT_PACK32: VkFormat = 55;
pub const VkFormat_VK_FORMAT_A8B8G8R8_SINT_PACK32: VkFormat = 56;
pub const VkFormat_VK_FORMAT_A8B8G8R8_SRGB_PACK32: VkFormat = 57;
pub const VkFormat_VK_FORMAT_A2R10G10B10_UNORM_PACK32: VkFormat = 58;
pub const VkFormat_VK_FORMAT_A2R10G10B10_SNORM_PACK32: VkFormat = 59;
pub const VkFormat_VK_FORMAT_A2R10G10B10_USCALED_PACK32: VkFormat = 60;
pub const VkFormat_VK_FORMAT_A2R10G10B10_SSCALED_PACK32: VkFormat = 61;
pub const VkFormat_VK_FORMAT_A2R10G10B10_UINT_PACK32: VkFormat = 62;
pub const VkFormat_VK_FORMAT_A2R10G10B10_SINT_PACK32: VkFormat = 63;
pub const VkFormat_VK_FORMAT_A2B10G10R10_UNORM_PACK32: VkFormat = 64;
pub const VkFormat_VK_FORMAT_A2B10G10R10_SNORM_PACK32: VkFormat = 65;
pub const VkFormat_VK_FORMAT_A2B10G10R10_USCALED_PACK32: VkFormat = 66;
pub const VkFormat_VK_FORMAT_A2B10G10R10_SSCALED_PACK32: VkFormat = 67;
pub const VkFormat_VK_FORMAT_A2B10G10R10_UINT_PACK32: VkFormat = 68;
pub const VkFormat_VK_FORMAT_A2B10G10R10_SINT_PACK32: VkFormat = 69;
pub const VkFormat_VK_FORMAT_R16_UNORM: VkFormat = 70;
pub const VkFormat_VK_FORMAT_R16_SNORM: VkFormat = 71;
pub const VkFormat_VK_FORMAT_R16_USCALED: VkFormat = 72;
pub const VkFormat_VK_FORMAT_R16_SSCALED: VkFormat = 73;
pub const VkFormat_VK_FORMAT_R16_UINT: VkFormat = 74;
pub const VkFormat_VK_FORMAT_R16_SINT: VkFormat = 75;
pub const VkFormat_VK_FORMAT_R16_SFLOAT: VkFormat = 76;
pub const VkFormat_VK_FORMAT_R16G16_UNORM: VkFormat = 77;
pub const VkFormat_VK_FORMAT_R16G16_SNORM: VkFormat = 78;
pub const VkFormat_VK_FORMAT_R16G16_USCALED: VkFormat = 79;
pub const VkFormat_VK_FORMAT_R16G16_SSCALED: VkFormat = 80;
pub const VkFormat_VK_FORMAT_R16G16_UINT: VkFormat = 81;
pub const VkFormat_VK_FORMAT_R16G16_SINT: VkFormat = 82;
pub const VkFormat_VK_FORMAT_R16G16_SFLOAT: VkFormat = 83;
pub const VkFormat_VK_FORMAT_R16G16B16_UNORM: VkFormat = 84;
pub const VkFormat_VK_FORMAT_R16G16B16_SNORM: VkFormat = 85;
pub const VkFormat_VK_FORMAT_R16G16B16_USCALED: VkFormat = 86;
pub const VkFormat_VK_FORMAT_R16G16B16_SSCALED: VkFormat = 87;
pub const VkFormat_VK_FORMAT_R16G16B16_UINT: VkFormat = 88;
pub const VkFormat_VK_FORMAT_R16G16B16_SINT: VkFormat = 89;
pub const VkFormat_VK_FORMAT_R16G16B16_SFLOAT: VkFormat = 90;
pub const VkFormat_VK_FORMAT_R16G16B16A16_UNORM: VkFormat = 91;
pub const VkFormat_VK_FORMAT_R16G16B16A16_SNORM: VkFormat = 92;
pub const VkFormat_VK_FORMAT_R16G16B16A16_USCALED: VkFormat = 93;
pub const VkFormat_VK_FORMAT_R16G16B16A16_SSCALED: VkFormat = 94;
pub const VkFormat_VK_FORMAT_R16G16B16A16_UINT: VkFormat = 95;
pub const VkFormat_VK_FORMAT_R16G16B16A16_SINT: VkFormat = 96;
pub const VkFormat_VK_FORMAT_R16G16B16A16_SFLOAT: VkFormat = 97;
pub const VkFormat_VK_FORMAT_R32_UINT: VkFormat = 98;
pub const VkFormat_VK_FORMAT_R32_SINT: VkFormat = 99;
pub const VkFormat_VK_FORMAT_R32_SFLOAT: VkFormat = 100;
pub const VkFormat_VK_FORMAT_R32G32_UINT: VkFormat = 101;
pub const VkFormat_VK_FORMAT_R32G32_SINT: VkFormat = 102;
pub const VkFormat_VK_FORMAT_R32G32_SFLOAT: VkFormat = 103;
pub const VkFormat_VK_FORMAT_R32G32B32_UINT: VkFormat = 104;
pub const VkFormat_VK_FORMAT_R32G32B32_SINT: VkFormat = 105;
pub const VkFormat_VK_FORMAT_R32G32B32_SFLOAT: VkFormat = 106;
pub const VkFormat_VK_FORMAT_R32G32B32A32_UINT: VkFormat = 107;
pub const VkFormat_VK_FORMAT_R32G32B32A32_SINT: VkFormat = 108;
pub const VkFormat_VK_FORMAT_R32G32B32A32_SFLOAT: VkFormat = 109;
pub const VkFormat_VK_FORMAT_R64_UINT: VkFormat = 110;
pub const VkFormat_VK_FORMAT_R64_SINT: VkFormat = 111;
pub const VkFormat_VK_FORMAT_R64_SFLOAT: VkFormat = 112;
pub const VkFormat_VK_FORMAT_R64G64_UINT: VkFormat = 113;
pub const VkFormat_VK_FORMAT_R64G64_SINT: VkFormat = 114;
pub const VkFormat_VK_FORMAT_R64G64_SFLOAT: VkFormat = 115;
pub const VkFormat_VK_FORMAT_R64G64B64_UINT: VkFormat = 116;
pub const VkFormat_VK_FORMAT_R64G64B64_SINT: VkFormat = 117;
pub const VkFormat_VK_FORMAT_R64G64B64_SFLOAT: VkFormat = 118;
pub const VkFormat_VK_FORMAT_R64G64B64A64_UINT: VkFormat = 119;
pub const VkFormat_VK_FORMAT_R64G64B64A64_SINT: VkFormat = 120;
pub const VkFormat_VK_FORMAT_R64G64B64A64_SFLOAT: VkFormat = 121;
pub const VkFormat_VK_FORMAT_B10G11R11_UFLOAT_PACK32: VkFormat = 122;
pub const VkFormat_VK_FORMAT_E5B9G9R9_UFLOAT_PACK32: VkFormat = 123;
pub const VkFormat_VK_FORMAT_D16_UNORM: VkFormat = 124;
pub const VkFormat_VK_FORMAT_X8_D24_UNORM_PACK32: VkFormat = 125;
pub const VkFormat_VK_FORMAT_D32_SFLOAT: VkFormat = 126;
pub const VkFormat_VK_FORMAT_S8_UINT: VkFormat = 127;
pub const VkFormat_VK_FORMAT_D16_UNORM_S8_UINT: VkFormat = 128;
pub const VkFormat_VK_FORMAT_D24_UNORM_S8_UINT: VkFormat = 129;
pub const VkFormat_VK_FORMAT_D32_SFLOAT_S8_UINT: VkFormat = 130;
pub const VkFormat_VK_FORMAT_BC1_RGB_UNORM_BLOCK: VkFormat = 131;
pub const VkFormat_VK_FORMAT_BC1_RGB_SRGB_BLOCK: VkFormat = 132;
pub const VkFormat_VK_FORMAT_BC1_RGBA_UNORM_BLOCK: VkFormat = 133;
pub const VkFormat_VK_FORMAT_BC1_RGBA_SRGB_BLOCK: VkFormat = 134;
pub const VkFormat_VK_FORMAT_BC2_UNORM_BLOCK: VkFormat = 135;
pub const VkFormat_VK_FORMAT_BC2_SRGB_BLOCK: VkFormat = 136;
pub const VkFormat_VK_FORMAT_BC3_UNORM_BLOCK: VkFormat = 137;
pub const VkFormat_VK_FORMAT_BC3_SRGB_BLOCK: VkFormat = 138;
pub const VkFormat_VK_FORMAT_BC4_UNORM_BLOCK: VkFormat = 139;
pub const VkFormat_VK_FORMAT_BC4_SNORM_BLOCK: VkFormat = 140;
pub const VkFormat_VK_FORMAT_BC5_UNORM_BLOCK: VkFormat = 141;
pub const VkFormat_VK_FORMAT_BC5_SNORM_BLOCK: VkFormat = 142;
pub const VkFormat_VK_FORMAT_BC6H_UFLOAT_BLOCK: VkFormat = 143;
pub const VkFormat_VK_FORMAT_BC6H_SFLOAT_BLOCK: VkFormat = 144;
pub const VkFormat_VK_FORMAT_BC7_UNORM_BLOCK: VkFormat = 145;
pub const VkFormat_VK_FORMAT_BC7_SRGB_BLOCK: VkFormat = 146;
pub const VkFormat_VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK: VkFormat = 147;
pub const VkFormat_VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK: VkFormat = 148;
pub const VkFormat_VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK: VkFormat = 149;
pub const VkFormat_VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK: VkFormat = 150;
pub const VkFormat_VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK: VkFormat = 151;
pub const VkFormat_VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK: VkFormat = 152;
pub const VkFormat_VK_FORMAT_EAC_R11_UNORM_BLOCK: VkFormat = 153;
pub const VkFormat_VK_FORMAT_EAC_R11_SNORM_BLOCK: VkFormat = 154;
pub const VkFormat_VK_FORMAT_EAC_R11G11_UNORM_BLOCK: VkFormat = 155;
pub const VkFormat_VK_FORMAT_EAC_R11G11_SNORM_BLOCK: VkFormat = 156;
pub const VkFormat_VK_FORMAT_ASTC_4x4_UNORM_BLOCK: VkFormat = 157;
pub const VkFormat_VK_FORMAT_ASTC_4x4_SRGB_BLOCK: VkFormat = 158;
pub const VkFormat_VK_FORMAT_ASTC_5x4_UNORM_BLOCK: VkFormat = 159;
pub const VkFormat_VK_FORMAT_ASTC_5x4_SRGB_BLOCK: VkFormat = 160;
pub const VkFormat_VK_FORMAT_ASTC_5x5_UNORM_BLOCK: VkFormat = 161;
pub const VkFormat_VK_FORMAT_ASTC_5x5_SRGB_BLOCK: VkFormat = 162;
pub const VkFormat_VK_FORMAT_ASTC_6x5_UNORM_BLOCK: VkFormat = 163;
pub const VkFormat_VK_FORMAT_ASTC_6x5_SRGB_BLOCK: VkFormat = 164;
pub const VkFormat_VK_FORMAT_ASTC_6x6_UNORM_BLOCK: VkFormat = 165;
pub const VkFormat_VK_FORMAT_ASTC_6x6_SRGB_BLOCK: VkFormat = 166;
pub const VkFormat_VK_FORMAT_ASTC_8x5_UNORM_BLOCK: VkFormat = 167;
pub const VkFormat_VK_FORMAT_ASTC_8x5_SRGB_BLOCK: VkFormat = 168;
pub const VkFormat_VK_FORMAT_ASTC_8x6_UNORM_BLOCK: VkFormat = 169;
pub const VkFormat_VK_FORMAT_ASTC_8x6_SRGB_BLOCK: VkFormat = 170;
pub const VkFormat_VK_FORMAT_ASTC_8x8_UNORM_BLOCK: VkFormat = 171;
pub const VkFormat_VK_FORMAT_ASTC_8x8_SRGB_BLOCK: VkFormat = 172;
pub const VkFormat_VK_FORMAT_ASTC_10x5_UNORM_BLOCK: VkFormat = 173;
pub const VkFormat_VK_FORMAT_ASTC_10x5_SRGB_BLOCK: VkFormat = 174;
pub const VkFormat_VK_FORMAT_ASTC_10x6_UNORM_BLOCK: VkFormat = 175;
pub const VkFormat_VK_FORMAT_ASTC_10x6_SRGB_BLOCK: VkFormat = 176;
pub const VkFormat_VK_FORMAT_ASTC_10x8_UNORM_BLOCK: VkFormat = 177;
pub const VkFormat_VK_FORMAT_ASTC_10x8_SRGB_BLOCK: VkFormat = 178;
pub const VkFormat_VK_FORMAT_ASTC_10x10_UNORM_BLOCK: VkFormat = 179;
pub const VkFormat_VK_FORMAT_ASTC_10x10_SRGB_BLOCK: VkFormat = 180;
pub const VkFormat_VK_FORMAT_ASTC_12x10_UNORM_BLOCK: VkFormat = 181;
pub const VkFormat_VK_FORMAT_ASTC_12x10_SRGB_BLOCK: VkFormat = 182;
pub const VkFormat_VK_FORMAT_ASTC_12x12_UNORM_BLOCK: VkFormat = 183;
pub const VkFormat_VK_FORMAT_ASTC_12x12_SRGB_BLOCK: VkFormat = 184;
pub const VkFormat_VK_FORMAT_G8B8G8R8_422_UNORM: VkFormat = 1000156000;
pub const VkFormat_VK_FORMAT_B8G8R8G8_422_UNORM: VkFormat = 1000156001;
pub const VkFormat_VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM: VkFormat = 1000156002;
pub const VkFormat_VK_FORMAT_G8_B8R8_2PLANE_420_UNORM: VkFormat = 1000156003;
pub const VkFormat_VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM: VkFormat = 1000156004;
pub const VkFormat_VK_FORMAT_G8_B8R8_2PLANE_422_UNORM: VkFormat = 1000156005;
pub const VkFormat_VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM: VkFormat = 1000156006;
pub const VkFormat_VK_FORMAT_R10X6_UNORM_PACK16: VkFormat = 1000156007;
pub const VkFormat_VK_FORMAT_R10X6G10X6_UNORM_2PACK16: VkFormat = 1000156008;
pub const VkFormat_VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16: VkFormat = 1000156009;
pub const VkFormat_VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16: VkFormat = 1000156010;
pub const VkFormat_VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16: VkFormat = 1000156011;
pub const VkFormat_VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16: VkFormat = 1000156012;
pub const VkFormat_VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16: VkFormat = 1000156013;
pub const VkFormat_VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16: VkFormat = 1000156014;
pub const VkFormat_VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16: VkFormat = 1000156015;
pub const VkFormat_VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16: VkFormat = 1000156016;
pub const VkFormat_VK_FORMAT_R12X4_UNORM_PACK16: VkFormat = 1000156017;
pub const VkFormat_VK_FORMAT_R12X4G12X4_UNORM_2PACK16: VkFormat = 1000156018;
pub const VkFormat_VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16: VkFormat = 1000156019;
pub const VkFormat_VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16: VkFormat = 1000156020;
pub const VkFormat_VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16: VkFormat = 1000156021;
pub const VkFormat_VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16: VkFormat = 1000156022;
pub const VkFormat_VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16: VkFormat = 1000156023;
pub const VkFormat_VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16: VkFormat = 1000156024;
pub const VkFormat_VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16: VkFormat = 1000156025;
pub const VkFormat_VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16: VkFormat = 1000156026;
pub const VkFormat_VK_FORMAT_G16B16G16R16_422_UNORM: VkFormat = 1000156027;
pub const VkFormat_VK_FORMAT_B16G16R16G16_422_UNORM: VkFormat = 1000156028;
pub const VkFormat_VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM: VkFormat = 1000156029;
pub const VkFormat_VK_FORMAT_G16_B16R16_2PLANE_420_UNORM: VkFormat = 1000156030;
pub const VkFormat_VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM: VkFormat = 1000156031;
pub const VkFormat_VK_FORMAT_G16_B16R16_2PLANE_422_UNORM: VkFormat = 1000156032;
pub const VkFormat_VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM: VkFormat = 1000156033;
pub const VkFormat_VK_FORMAT_G8_B8R8_2PLANE_444_UNORM: VkFormat = 1000330000;
pub const VkFormat_VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16: VkFormat = 1000330001;
pub const VkFormat_VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16: VkFormat = 1000330002;
pub const VkFormat_VK_FORMAT_G16_B16R16_2PLANE_444_UNORM: VkFormat = 1000330003;
pub const VkFormat_VK_FORMAT_A4R4G4B4_UNORM_PACK16: VkFormat = 1000340000;
pub const VkFormat_VK_FORMAT_A4B4G4R4_UNORM_PACK16: VkFormat = 1000340001;
pub const VkFormat_VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK: VkFormat = 1000066000;
pub const VkFormat_VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK: VkFormat = 1000066001;
pub const VkFormat_VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK: VkFormat = 1000066002;
pub const VkFormat_VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK: VkFormat = 1000066003;
pub const VkFormat_VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK: VkFormat = 1000066004;
pub const VkFormat_VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK: VkFormat = 1000066005;
pub const VkFormat_VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK: VkFormat = 1000066006;
pub const VkFormat_VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK: VkFormat = 1000066007;
pub const VkFormat_VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK: VkFormat = 1000066008;
pub const VkFormat_VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK: VkFormat = 1000066009;
pub const VkFormat_VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK: VkFormat = 1000066010;
pub const VkFormat_VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK: VkFormat = 1000066011;
pub const VkFormat_VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK: VkFormat = 1000066012;
pub const VkFormat_VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK: VkFormat = 1000066013;
pub const VkFormat_VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG: VkFormat = 1000054000;
pub const VkFormat_VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG: VkFormat = 1000054001;
pub const VkFormat_VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG: VkFormat = 1000054002;
pub const VkFormat_VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG: VkFormat = 1000054003;
pub const VkFormat_VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG: VkFormat = 1000054004;
pub const VkFormat_VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG: VkFormat = 1000054005;
pub const VkFormat_VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG: VkFormat = 1000054006;
pub const VkFormat_VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG: VkFormat = 1000054007;
pub const VkFormat_VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT: VkFormat = 1000066000;
pub const VkFormat_VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT: VkFormat = 1000066001;
pub const VkFormat_VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT: VkFormat = 1000066002;
pub const VkFormat_VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT: VkFormat = 1000066003;
pub const VkFormat_VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT: VkFormat = 1000066004;
pub const VkFormat_VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT: VkFormat = 1000066005;
pub const VkFormat_VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT: VkFormat = 1000066006;
pub const VkFormat_VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT: VkFormat = 1000066007;
pub const VkFormat_VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT: VkFormat = 1000066008;
pub const VkFormat_VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT: VkFormat = 1000066009;
pub const VkFormat_VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT: VkFormat = 1000066010;
pub const VkFormat_VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT: VkFormat = 1000066011;
pub const VkFormat_VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT: VkFormat = 1000066012;
pub const VkFormat_VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT: VkFormat = 1000066013;
pub const VkFormat_VK_FORMAT_G8B8G8R8_422_UNORM_KHR: VkFormat = 1000156000;
pub const VkFormat_VK_FORMAT_B8G8R8G8_422_UNORM_KHR: VkFormat = 1000156001;
pub const VkFormat_VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM_KHR: VkFormat = 1000156002;
pub const VkFormat_VK_FORMAT_G8_B8R8_2PLANE_420_UNORM_KHR: VkFormat = 1000156003;
pub const VkFormat_VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM_KHR: VkFormat = 1000156004;
pub const VkFormat_VK_FORMAT_G8_B8R8_2PLANE_422_UNORM_KHR: VkFormat = 1000156005;
pub const VkFormat_VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM_KHR: VkFormat = 1000156006;
pub const VkFormat_VK_FORMAT_R10X6_UNORM_PACK16_KHR: VkFormat = 1000156007;
pub const VkFormat_VK_FORMAT_R10X6G10X6_UNORM_2PACK16_KHR: VkFormat = 1000156008;
pub const VkFormat_VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR: VkFormat = 1000156009;
pub const VkFormat_VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR: VkFormat = 1000156010;
pub const VkFormat_VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR: VkFormat = 1000156011;
pub const VkFormat_VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR: VkFormat = 1000156012;
pub const VkFormat_VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR: VkFormat = 1000156013;
pub const VkFormat_VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR: VkFormat = 1000156014;
pub const VkFormat_VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR: VkFormat = 1000156015;
pub const VkFormat_VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR: VkFormat = 1000156016;
pub const VkFormat_VK_FORMAT_R12X4_UNORM_PACK16_KHR: VkFormat = 1000156017;
pub const VkFormat_VK_FORMAT_R12X4G12X4_UNORM_2PACK16_KHR: VkFormat = 1000156018;
pub const VkFormat_VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR: VkFormat = 1000156019;
pub const VkFormat_VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR: VkFormat = 1000156020;
pub const VkFormat_VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR: VkFormat = 1000156021;
pub const VkFormat_VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR: VkFormat = 1000156022;
pub const VkFormat_VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR: VkFormat = 1000156023;
pub const VkFormat_VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR: VkFormat = 1000156024;
pub const VkFormat_VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR: VkFormat = 1000156025;
pub const VkFormat_VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR: VkFormat = 1000156026;
pub const VkFormat_VK_FORMAT_G16B16G16R16_422_UNORM_KHR: VkFormat = 1000156027;
pub const VkFormat_VK_FORMAT_B16G16R16G16_422_UNORM_KHR: VkFormat = 1000156028;
pub const VkFormat_VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM_KHR: VkFormat = 1000156029;
pub const VkFormat_VK_FORMAT_G16_B16R16_2PLANE_420_UNORM_KHR: VkFormat = 1000156030;
pub const VkFormat_VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM_KHR: VkFormat = 1000156031;
pub const VkFormat_VK_FORMAT_G16_B16R16_2PLANE_422_UNORM_KHR: VkFormat = 1000156032;
pub const VkFormat_VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM_KHR: VkFormat = 1000156033;
pub const VkFormat_VK_FORMAT_G8_B8R8_2PLANE_444_UNORM_EXT: VkFormat = 1000330000;
pub const VkFormat_VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16_EXT: VkFormat = 1000330001;
pub const VkFormat_VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16_EXT: VkFormat = 1000330002;
pub const VkFormat_VK_FORMAT_G16_B16R16_2PLANE_444_UNORM_EXT: VkFormat = 1000330003;
pub const VkFormat_VK_FORMAT_A4R4G4B4_UNORM_PACK16_EXT: VkFormat = 1000340000;
pub const VkFormat_VK_FORMAT_A4B4G4R4_UNORM_PACK16_EXT: VkFormat = 1000340001;
pub const VkFormat_VK_FORMAT_MAX_ENUM: VkFormat = 2147483647;
pub type VkFormat = ::std::os::raw::c_uint;
pub const VkImageTiling_VK_IMAGE_TILING_OPTIMAL: VkImageTiling = 0;
pub const VkImageTiling_VK_IMAGE_TILING_LINEAR: VkImageTiling = 1;
pub const VkImageTiling_VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT: VkImageTiling = 1000158000;
pub const VkImageTiling_VK_IMAGE_TILING_MAX_ENUM: VkImageTiling = 2147483647;
pub type VkImageTiling = ::std::os::raw::c_uint;
pub const VkImageType_VK_IMAGE_TYPE_1D: VkImageType = 0;
pub const VkImageType_VK_IMAGE_TYPE_2D: VkImageType = 1;
pub const VkImageType_VK_IMAGE_TYPE_3D: VkImageType = 2;
pub const VkImageType_VK_IMAGE_TYPE_MAX_ENUM: VkImageType = 2147483647;
pub type VkImageType = ::std::os::raw::c_uint;
pub const VkPhysicalDeviceType_VK_PHYSICAL_DEVICE_TYPE_OTHER: VkPhysicalDeviceType = 0;
pub const VkPhysicalDeviceType_VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU: VkPhysicalDeviceType = 1;
pub const VkPhysicalDeviceType_VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU: VkPhysicalDeviceType = 2;
pub const VkPhysicalDeviceType_VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU: VkPhysicalDeviceType = 3;
pub const VkPhysicalDeviceType_VK_PHYSICAL_DEVICE_TYPE_CPU: VkPhysicalDeviceType = 4;
pub const VkPhysicalDeviceType_VK_PHYSICAL_DEVICE_TYPE_MAX_ENUM: VkPhysicalDeviceType = 2147483647;
pub type VkPhysicalDeviceType = ::std::os::raw::c_uint;
pub const VkSharingMode_VK_SHARING_MODE_EXCLUSIVE: VkSharingMode = 0;
pub const VkSharingMode_VK_SHARING_MODE_CONCURRENT: VkSharingMode = 1;
pub const VkSharingMode_VK_SHARING_MODE_MAX_ENUM: VkSharingMode = 2147483647;
pub type VkSharingMode = ::std::os::raw::c_uint;
pub const VkImageAspectFlagBits_VK_IMAGE_ASPECT_COLOR_BIT: VkImageAspectFlagBits = 1;
pub const VkImageAspectFlagBits_VK_IMAGE_ASPECT_DEPTH_BIT: VkImageAspectFlagBits = 2;
pub const VkImageAspectFlagBits_VK_IMAGE_ASPECT_STENCIL_BIT: VkImageAspectFlagBits = 4;
pub const VkImageAspectFlagBits_VK_IMAGE_ASPECT_METADATA_BIT: VkImageAspectFlagBits = 8;
pub const VkImageAspectFlagBits_VK_IMAGE_ASPECT_PLANE_0_BIT: VkImageAspectFlagBits = 16;
pub const VkImageAspectFlagBits_VK_IMAGE_ASPECT_PLANE_1_BIT: VkImageAspectFlagBits = 32;
pub const VkImageAspectFlagBits_VK_IMAGE_ASPECT_PLANE_2_BIT: VkImageAspectFlagBits = 64;
pub const VkImageAspectFlagBits_VK_IMAGE_ASPECT_NONE: VkImageAspectFlagBits = 0;
pub const VkImageAspectFlagBits_VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT: VkImageAspectFlagBits = 128;
pub const VkImageAspectFlagBits_VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT: VkImageAspectFlagBits = 256;
pub const VkImageAspectFlagBits_VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT: VkImageAspectFlagBits = 512;
pub const VkImageAspectFlagBits_VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT: VkImageAspectFlagBits =
    1024;
pub const VkImageAspectFlagBits_VK_IMAGE_ASPECT_PLANE_0_BIT_KHR: VkImageAspectFlagBits = 16;
pub const VkImageAspectFlagBits_VK_IMAGE_ASPECT_PLANE_1_BIT_KHR: VkImageAspectFlagBits = 32;
pub const VkImageAspectFlagBits_VK_IMAGE_ASPECT_PLANE_2_BIT_KHR: VkImageAspectFlagBits = 64;
pub const VkImageAspectFlagBits_VK_IMAGE_ASPECT_NONE_KHR: VkImageAspectFlagBits = 0;
pub const VkImageAspectFlagBits_VK_IMAGE_ASPECT_FLAG_BITS_MAX_ENUM: VkImageAspectFlagBits =
    2147483647;
pub type VkImageAspectFlagBits = ::std::os::raw::c_uint;
pub type VkImageCreateFlags = VkFlags;
pub const VkSampleCountFlagBits_VK_SAMPLE_COUNT_1_BIT: VkSampleCountFlagBits = 1;
pub const VkSampleCountFlagBits_VK_SAMPLE_COUNT_2_BIT: VkSampleCountFlagBits = 2;
pub const VkSampleCountFlagBits_VK_SAMPLE_COUNT_4_BIT: VkSampleCountFlagBits = 4;
pub const VkSampleCountFlagBits_VK_SAMPLE_COUNT_8_BIT: VkSampleCountFlagBits = 8;
pub const VkSampleCountFlagBits_VK_SAMPLE_COUNT_16_BIT: VkSampleCountFlagBits = 16;
pub const VkSampleCountFlagBits_VK_SAMPLE_COUNT_32_BIT: VkSampleCountFlagBits = 32;
pub const VkSampleCountFlagBits_VK_SAMPLE_COUNT_64_BIT: VkSampleCountFlagBits = 64;
pub const VkSampleCountFlagBits_VK_SAMPLE_COUNT_FLAG_BITS_MAX_ENUM: VkSampleCountFlagBits =
    2147483647;
pub type VkSampleCountFlagBits = ::std::os::raw::c_uint;
pub type VkSampleCountFlags = VkFlags;
pub type VkImageUsageFlags = VkFlags;
pub type VkMemoryHeapFlags = VkFlags;
pub type VkMemoryPropertyFlags = VkFlags;
pub type VkMemoryMapFlags = VkFlags;
pub type VkBufferCreateFlags = VkFlags;
pub type VkBufferUsageFlags = VkFlags;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkExtent3D {
    pub width: u32,
    pub height: u32,
    pub depth: u32,
}
pub type PFN_vkAllocationFunction = ::std::option::Option<
    unsafe extern "C" fn(
        pUserData: *mut ::std::os::raw::c_void,
        size: usize,
        alignment: usize,
        allocationScope: VkSystemAllocationScope,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type PFN_vkFreeFunction = ::std::option::Option<
    unsafe extern "C" fn(
        pUserData: *mut ::std::os::raw::c_void,
        pMemory: *mut ::std::os::raw::c_void,
    ),
>;
pub type PFN_vkInternalAllocationNotification = ::std::option::Option<
    unsafe extern "C" fn(
        pUserData: *mut ::std::os::raw::c_void,
        size: usize,
        allocationType: VkInternalAllocationType,
        allocationScope: VkSystemAllocationScope,
    ),
>;
pub type PFN_vkInternalFreeNotification = ::std::option::Option<
    unsafe extern "C" fn(
        pUserData: *mut ::std::os::raw::c_void,
        size: usize,
        allocationType: VkInternalAllocationType,
        allocationScope: VkSystemAllocationScope,
    ),
>;
pub type PFN_vkReallocationFunction = ::std::option::Option<
    unsafe extern "C" fn(
        pUserData: *mut ::std::os::raw::c_void,
        pOriginal: *mut ::std::os::raw::c_void,
        size: usize,
        alignment: usize,
        allocationScope: VkSystemAllocationScope,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type PFN_vkVoidFunction = ::std::option::Option<unsafe extern "C" fn()>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkAllocationCallbacks {
    pub pUserData: *mut ::std::os::raw::c_void,
    pub pfnAllocation: PFN_vkAllocationFunction,
    pub pfnReallocation: PFN_vkReallocationFunction,
    pub pfnFree: PFN_vkFreeFunction,
    pub pfnInternalAllocation: PFN_vkInternalAllocationNotification,
    pub pfnInternalFree: PFN_vkInternalFreeNotification,
}
impl Default for VkAllocationCallbacks {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkMemoryHeap {
    pub size: VkDeviceSize,
    pub flags: VkMemoryHeapFlags,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkMemoryType {
    pub propertyFlags: VkMemoryPropertyFlags,
    pub heapIndex: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkPhysicalDeviceLimits {
    pub maxImageDimension1D: u32,
    pub maxImageDimension2D: u32,
    pub maxImageDimension3D: u32,
    pub maxImageDimensionCube: u32,
    pub maxImageArrayLayers: u32,
    pub maxTexelBufferElements: u32,
    pub maxUniformBufferRange: u32,
    pub maxStorageBufferRange: u32,
    pub maxPushConstantsSize: u32,
    pub maxMemoryAllocationCount: u32,
    pub maxSamplerAllocationCount: u32,
    pub bufferImageGranularity: VkDeviceSize,
    pub sparseAddressSpaceSize: VkDeviceSize,
    pub maxBoundDescriptorSets: u32,
    pub maxPerStageDescriptorSamplers: u32,
    pub maxPerStageDescriptorUniformBuffers: u32,
    pub maxPerStageDescriptorStorageBuffers: u32,
    pub maxPerStageDescriptorSampledImages: u32,
    pub maxPerStageDescriptorStorageImages: u32,
    pub maxPerStageDescriptorInputAttachments: u32,
    pub maxPerStageResources: u32,
    pub maxDescriptorSetSamplers: u32,
    pub maxDescriptorSetUniformBuffers: u32,
    pub maxDescriptorSetUniformBuffersDynamic: u32,
    pub maxDescriptorSetStorageBuffers: u32,
    pub maxDescriptorSetStorageBuffersDynamic: u32,
    pub maxDescriptorSetSampledImages: u32,
    pub maxDescriptorSetStorageImages: u32,
    pub maxDescriptorSetInputAttachments: u32,
    pub maxVertexInputAttributes: u32,
    pub maxVertexInputBindings: u32,
    pub maxVertexInputAttributeOffset: u32,
    pub maxVertexInputBindingStride: u32,
    pub maxVertexOutputComponents: u32,
    pub maxTessellationGenerationLevel: u32,
    pub maxTessellationPatchSize: u32,
    pub maxTessellationControlPerVertexInputComponents: u32,
    pub maxTessellationControlPerVertexOutputComponents: u32,
    pub maxTessellationControlPerPatchOutputComponents: u32,
    pub maxTessellationControlTotalOutputComponents: u32,
    pub maxTessellationEvaluationInputComponents: u32,
    pub maxTessellationEvaluationOutputComponents: u32,
    pub maxGeometryShaderInvocations: u32,
    pub maxGeometryInputComponents: u32,
    pub maxGeometryOutputComponents: u32,
    pub maxGeometryOutputVertices: u32,
    pub maxGeometryTotalOutputComponents: u32,
    pub maxFragmentInputComponents: u32,
    pub maxFragmentOutputAttachments: u32,
    pub maxFragmentDualSrcAttachments: u32,
    pub maxFragmentCombinedOutputResources: u32,
    pub maxComputeSharedMemorySize: u32,
    pub maxComputeWorkGroupCount: [u32; 3usize],
    pub maxComputeWorkGroupInvocations: u32,
    pub maxComputeWorkGroupSize: [u32; 3usize],
    pub subPixelPrecisionBits: u32,
    pub subTexelPrecisionBits: u32,
    pub mipmapPrecisionBits: u32,
    pub maxDrawIndexedIndexValue: u32,
    pub maxDrawIndirectCount: u32,
    pub maxSamplerLodBias: f32,
    pub maxSamplerAnisotropy: f32,
    pub maxViewports: u32,
    pub maxViewportDimensions: [u32; 2usize],
    pub viewportBoundsRange: [f32; 2usize],
    pub viewportSubPixelBits: u32,
    pub minMemoryMapAlignment: usize,
    pub minTexelBufferOffsetAlignment: VkDeviceSize,
    pub minUniformBufferOffsetAlignment: VkDeviceSize,
    pub minStorageBufferOffsetAlignment: VkDeviceSize,
    pub minTexelOffset: i32,
    pub maxTexelOffset: u32,
    pub minTexelGatherOffset: i32,
    pub maxTexelGatherOffset: u32,
    pub minInterpolationOffset: f32,
    pub maxInterpolationOffset: f32,
    pub subPixelInterpolationOffsetBits: u32,
    pub maxFramebufferWidth: u32,
    pub maxFramebufferHeight: u32,
    pub maxFramebufferLayers: u32,
    pub framebufferColorSampleCounts: VkSampleCountFlags,
    pub framebufferDepthSampleCounts: VkSampleCountFlags,
    pub framebufferStencilSampleCounts: VkSampleCountFlags,
    pub framebufferNoAttachmentsSampleCounts: VkSampleCountFlags,
    pub maxColorAttachments: u32,
    pub sampledImageColorSampleCounts: VkSampleCountFlags,
    pub sampledImageIntegerSampleCounts: VkSampleCountFlags,
    pub sampledImageDepthSampleCounts: VkSampleCountFlags,
    pub sampledImageStencilSampleCounts: VkSampleCountFlags,
    pub storageImageSampleCounts: VkSampleCountFlags,
    pub maxSampleMaskWords: u32,
    pub timestampComputeAndGraphics: VkBool32,
    pub timestampPeriod: f32,
    pub maxClipDistances: u32,
    pub maxCullDistances: u32,
    pub maxCombinedClipAndCullDistances: u32,
    pub discreteQueuePriorities: u32,
    pub pointSizeRange: [f32; 2usize],
    pub lineWidthRange: [f32; 2usize],
    pub pointSizeGranularity: f32,
    pub lineWidthGranularity: f32,
    pub strictLines: VkBool32,
    pub standardSampleLocations: VkBool32,
    pub optimalBufferCopyOffsetAlignment: VkDeviceSize,
    pub optimalBufferCopyRowPitchAlignment: VkDeviceSize,
    pub nonCoherentAtomSize: VkDeviceSize,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkPhysicalDeviceMemoryProperties {
    pub memoryTypeCount: u32,
    pub memoryTypes: [VkMemoryType; 32usize],
    pub memoryHeapCount: u32,
    pub memoryHeaps: [VkMemoryHeap; 16usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkPhysicalDeviceSparseProperties {
    pub residencyStandard2DBlockShape: VkBool32,
    pub residencyStandard2DMultisampleBlockShape: VkBool32,
    pub residencyStandard3DBlockShape: VkBool32,
    pub residencyAlignedMipSize: VkBool32,
    pub residencyNonResidentStrict: VkBool32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceProperties {
    pub apiVersion: u32,
    pub driverVersion: u32,
    pub vendorID: u32,
    pub deviceID: u32,
    pub deviceType: VkPhysicalDeviceType,
    pub deviceName: [::std::os::raw::c_char; 256usize],
    pub pipelineCacheUUID: [u8; 16usize],
    pub limits: VkPhysicalDeviceLimits,
    pub sparseProperties: VkPhysicalDeviceSparseProperties,
}
impl Default for VkPhysicalDeviceProperties {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkMappedMemoryRange {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub memory: VkDeviceMemory,
    pub offset: VkDeviceSize,
    pub size: VkDeviceSize,
}
impl Default for VkMappedMemoryRange {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkMemoryAllocateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub allocationSize: VkDeviceSize,
    pub memoryTypeIndex: u32,
}
impl Default for VkMemoryAllocateInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkMemoryRequirements {
    pub size: VkDeviceSize,
    pub alignment: VkDeviceSize,
    pub memoryTypeBits: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkBufferCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkBufferCreateFlags,
    pub size: VkDeviceSize,
    pub usage: VkBufferUsageFlags,
    pub sharingMode: VkSharingMode,
    pub queueFamilyIndexCount: u32,
    pub pQueueFamilyIndices: *const u32,
}
impl Default for VkBufferCreateInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkImageCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkImageCreateFlags,
    pub imageType: VkImageType,
    pub format: VkFormat,
    pub extent: VkExtent3D,
    pub mipLevels: u32,
    pub arrayLayers: u32,
    pub samples: VkSampleCountFlagBits,
    pub tiling: VkImageTiling,
    pub usage: VkImageUsageFlags,
    pub sharingMode: VkSharingMode,
    pub queueFamilyIndexCount: u32,
    pub pQueueFamilyIndices: *const u32,
    pub initialLayout: VkImageLayout,
}
impl Default for VkImageCreateInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkBufferCopy {
    pub srcOffset: VkDeviceSize,
    pub dstOffset: VkDeviceSize,
    pub size: VkDeviceSize,
}
pub type PFN_vkGetPhysicalDeviceProperties = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pProperties: *mut VkPhysicalDeviceProperties,
    ),
>;
pub type PFN_vkGetPhysicalDeviceMemoryProperties = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pMemoryProperties: *mut VkPhysicalDeviceMemoryProperties,
    ),
>;
pub type PFN_vkGetInstanceProcAddr = ::std::option::Option<
    unsafe extern "C" fn(
        instance: VkInstance,
        pName: *const ::std::os::raw::c_char,
    ) -> PFN_vkVoidFunction,
>;
pub type PFN_vkGetDeviceProcAddr = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pName: *const ::std::os::raw::c_char,
    ) -> PFN_vkVoidFunction,
>;
pub type PFN_vkAllocateMemory = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pAllocateInfo: *const VkMemoryAllocateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pMemory: *mut VkDeviceMemory,
    ) -> VkResult,
>;
pub type PFN_vkFreeMemory = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        memory: VkDeviceMemory,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
pub type PFN_vkMapMemory = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        memory: VkDeviceMemory,
        offset: VkDeviceSize,
        size: VkDeviceSize,
        flags: VkMemoryMapFlags,
        ppData: *mut *mut ::std::os::raw::c_void,
    ) -> VkResult,
>;
pub type PFN_vkUnmapMemory =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice, memory: VkDeviceMemory)>;
pub type PFN_vkFlushMappedMemoryRanges = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        memoryRangeCount: u32,
        pMemoryRanges: *const VkMappedMemoryRange,
    ) -> VkResult,
>;
pub type PFN_vkInvalidateMappedMemoryRanges = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        memoryRangeCount: u32,
        pMemoryRanges: *const VkMappedMemoryRange,
    ) -> VkResult,
>;
pub type PFN_vkBindBufferMemory = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        buffer: VkBuffer,
        memory: VkDeviceMemory,
        memoryOffset: VkDeviceSize,
    ) -> VkResult,
>;
pub type PFN_vkBindImageMemory = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        image: VkImage,
        memory: VkDeviceMemory,
        memoryOffset: VkDeviceSize,
    ) -> VkResult,
>;
pub type PFN_vkGetBufferMemoryRequirements = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        buffer: VkBuffer,
        pMemoryRequirements: *mut VkMemoryRequirements,
    ),
>;
pub type PFN_vkGetImageMemoryRequirements = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        image: VkImage,
        pMemoryRequirements: *mut VkMemoryRequirements,
    ),
>;
pub type PFN_vkCreateBuffer = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkBufferCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pBuffer: *mut VkBuffer,
    ) -> VkResult,
>;
pub type PFN_vkDestroyBuffer = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        buffer: VkBuffer,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
pub type PFN_vkCreateImage = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkImageCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pImage: *mut VkImage,
    ) -> VkResult,
>;
pub type PFN_vkDestroyImage = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        image: VkImage,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
pub type PFN_vkCmdCopyBuffer = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        srcBuffer: VkBuffer,
        dstBuffer: VkBuffer,
        regionCount: u32,
        pRegions: *const VkBufferCopy,
    ),
>;
pub type VkExternalMemoryHandleTypeFlags = VkFlags;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkBindBufferMemoryInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub buffer: VkBuffer,
    pub memory: VkDeviceMemory,
    pub memoryOffset: VkDeviceSize,
}
impl Default for VkBindBufferMemoryInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkBindImageMemoryInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub image: VkImage,
    pub memory: VkDeviceMemory,
    pub memoryOffset: VkDeviceSize,
}
impl Default for VkBindImageMemoryInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkBufferMemoryRequirementsInfo2 {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub buffer: VkBuffer,
}
impl Default for VkBufferMemoryRequirementsInfo2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkImageMemoryRequirementsInfo2 {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub image: VkImage,
}
impl Default for VkImageMemoryRequirementsInfo2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkMemoryRequirements2 {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub memoryRequirements: VkMemoryRequirements,
}
impl Default for VkMemoryRequirements2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceMemoryProperties2 {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub memoryProperties: VkPhysicalDeviceMemoryProperties,
}
impl Default for VkPhysicalDeviceMemoryProperties2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDeviceBufferMemoryRequirements {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub pCreateInfo: *const VkBufferCreateInfo,
}
impl Default for VkDeviceBufferMemoryRequirements {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDeviceImageMemoryRequirements {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub pCreateInfo: *const VkImageCreateInfo,
    pub planeAspect: VkImageAspectFlagBits,
}
impl Default for VkDeviceImageMemoryRequirements {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFN_vkGetDeviceBufferMemoryRequirements = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pInfo: *const VkDeviceBufferMemoryRequirements,
        pMemoryRequirements: *mut VkMemoryRequirements2,
    ),
>;
pub type PFN_vkGetDeviceImageMemoryRequirements = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pInfo: *const VkDeviceImageMemoryRequirements,
        pMemoryRequirements: *mut VkMemoryRequirements2,
    ),
>;
pub type PFN_vkGetPhysicalDeviceMemoryProperties2KHR = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pMemoryProperties: *mut VkPhysicalDeviceMemoryProperties2,
    ),
>;
pub type VkExternalMemoryHandleTypeFlagsKHR = VkExternalMemoryHandleTypeFlags;
pub type PFN_vkGetImageMemoryRequirements2KHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pInfo: *const VkImageMemoryRequirementsInfo2,
        pMemoryRequirements: *mut VkMemoryRequirements2,
    ),
>;
pub type PFN_vkGetBufferMemoryRequirements2KHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pInfo: *const VkBufferMemoryRequirementsInfo2,
        pMemoryRequirements: *mut VkMemoryRequirements2,
    ),
>;
pub type PFN_vkBindBufferMemory2KHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        bindInfoCount: u32,
        pBindInfos: *const VkBindBufferMemoryInfo,
    ) -> VkResult,
>;
pub type PFN_vkBindImageMemory2KHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        bindInfoCount: u32,
        pBindInfos: *const VkBindImageMemoryInfo,
    ) -> VkResult,
>;
#[doc = " \\brief Allocator and all objects created from it will not be synchronized internally, so you must guarantee they are used from only one thread at a time or synchronized externally by you."]
#[doc = ""]
#[doc = "Using this flag may increase performance because internal mutexes are not used."]
pub const VmaAllocatorCreateFlagBits_VMA_ALLOCATOR_CREATE_EXTERNALLY_SYNCHRONIZED_BIT:
    VmaAllocatorCreateFlagBits = 1;
#[doc = " \\brief Enables usage of VK_KHR_dedicated_allocation extension."]
#[doc = ""]
#[doc = "The flag works only if VmaAllocatorCreateInfo::vulkanApiVersion `== VK_API_VERSION_1_0`."]
#[doc = "When it is `VK_API_VERSION_1_1`, the flag is ignored because the extension has been promoted to Vulkan 1.1."]
#[doc = ""]
#[doc = "Using this extension will automatically allocate dedicated blocks of memory for"]
#[doc = "some buffers and images instead of suballocating place for them out of bigger"]
#[doc = "memory blocks (as if you explicitly used #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"]
#[doc = "flag) when it is recommended by the driver. It may improve performance on some"]
#[doc = "GPUs."]
#[doc = ""]
#[doc = "You may set this flag only if you found out that following device extensions are"]
#[doc = "supported, you enabled them while creating Vulkan device passed as"]
#[doc = "VmaAllocatorCreateInfo::device, and you want them to be used internally by this"]
#[doc = "library:"]
#[doc = ""]
#[doc = "- VK_KHR_get_memory_requirements2 (device extension)"]
#[doc = "- VK_KHR_dedicated_allocation (device extension)"]
#[doc = ""]
#[doc = "When this flag is set, you can experience following warnings reported by Vulkan"]
#[doc = "validation layer. You can ignore them."]
#[doc = ""]
#[doc = "> vkBindBufferMemory(): Binding memory to buffer 0x2d but vkGetBufferMemoryRequirements() has not been called on that buffer."]
pub const VmaAllocatorCreateFlagBits_VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT:
    VmaAllocatorCreateFlagBits = 2;
#[doc = "Enables usage of VK_KHR_bind_memory2 extension."]
#[doc = ""]
#[doc = "The flag works only if VmaAllocatorCreateInfo::vulkanApiVersion `== VK_API_VERSION_1_0`."]
#[doc = "When it is `VK_API_VERSION_1_1`, the flag is ignored because the extension has been promoted to Vulkan 1.1."]
#[doc = ""]
#[doc = "You may set this flag only if you found out that this device extension is supported,"]
#[doc = "you enabled it while creating Vulkan device passed as VmaAllocatorCreateInfo::device,"]
#[doc = "and you want it to be used internally by this library."]
#[doc = ""]
#[doc = "The extension provides functions `vkBindBufferMemory2KHR` and `vkBindImageMemory2KHR`,"]
#[doc = "which allow to pass a chain of `pNext` structures while binding."]
#[doc = "This flag is required if you use `pNext` parameter in vmaBindBufferMemory2() or vmaBindImageMemory2()."]
pub const VmaAllocatorCreateFlagBits_VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT:
    VmaAllocatorCreateFlagBits = 4;
#[doc = "Enables usage of VK_EXT_memory_budget extension."]
#[doc = ""]
#[doc = "You may set this flag only if you found out that this device extension is supported,"]
#[doc = "you enabled it while creating Vulkan device passed as VmaAllocatorCreateInfo::device,"]
#[doc = "and you want it to be used internally by this library, along with another instance extension"]
#[doc = "VK_KHR_get_physical_device_properties2, which is required by it (or Vulkan 1.1, where this extension is promoted)."]
#[doc = ""]
#[doc = "The extension provides query for current memory usage and budget, which will probably"]
#[doc = "be more accurate than an estimation used by the library otherwise."]
pub const VmaAllocatorCreateFlagBits_VMA_ALLOCATOR_CREATE_EXT_MEMORY_BUDGET_BIT:
    VmaAllocatorCreateFlagBits = 8;
#[doc = "Enables usage of VK_AMD_device_coherent_memory extension."]
#[doc = ""]
#[doc = "You may set this flag only if you:"]
#[doc = ""]
#[doc = "- found out that this device extension is supported and enabled it while creating Vulkan device passed as VmaAllocatorCreateInfo::device,"]
#[doc = "- checked that `VkPhysicalDeviceCoherentMemoryFeaturesAMD::deviceCoherentMemory` is true and set it while creating the Vulkan device,"]
#[doc = "- want it to be used internally by this library."]
#[doc = ""]
#[doc = "The extension and accompanying device feature provide access to memory types with"]
#[doc = "`VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD` and `VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD` flags."]
#[doc = "They are useful mostly for writing breadcrumb markers - a common method for debugging GPU crash/hang/TDR."]
#[doc = ""]
#[doc = "When the extension is not enabled, such memory types are still enumerated, but their usage is illegal."]
#[doc = "To protect from this error, if you don't create the allocator with this flag, it will refuse to allocate any memory or create a custom pool in such memory type,"]
#[doc = "returning `VK_ERROR_FEATURE_NOT_PRESENT`."]
pub const VmaAllocatorCreateFlagBits_VMA_ALLOCATOR_CREATE_AMD_DEVICE_COHERENT_MEMORY_BIT:
    VmaAllocatorCreateFlagBits = 16;
#[doc = "Enables usage of \"buffer device address\" feature, which allows you to use function"]
#[doc = "`vkGetBufferDeviceAddress*` to get raw GPU pointer to a buffer and pass it for usage inside a shader."]
#[doc = ""]
#[doc = "You may set this flag only if you:"]
#[doc = ""]
#[doc = "1. (For Vulkan version < 1.2) Found as available and enabled device extension"]
#[doc = "VK_KHR_buffer_device_address."]
#[doc = "This extension is promoted to core Vulkan 1.2."]
#[doc = "2. Found as available and enabled device feature `VkPhysicalDeviceBufferDeviceAddressFeatures::bufferDeviceAddress`."]
#[doc = ""]
#[doc = "When this flag is set, you can create buffers with `VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT` using VMA."]
#[doc = "The library automatically adds `VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT` to"]
#[doc = "allocated memory blocks wherever it might be needed."]
#[doc = ""]
#[doc = "For more information, see documentation chapter \\ref enabling_buffer_device_address."]
pub const VmaAllocatorCreateFlagBits_VMA_ALLOCATOR_CREATE_BUFFER_DEVICE_ADDRESS_BIT:
    VmaAllocatorCreateFlagBits = 32;
#[doc = "Enables usage of VK_EXT_memory_priority extension in the library."]
#[doc = ""]
#[doc = "You may set this flag only if you found available and enabled this device extension,"]
#[doc = "along with `VkPhysicalDeviceMemoryPriorityFeaturesEXT::memoryPriority == VK_TRUE`,"]
#[doc = "while creating Vulkan device passed as VmaAllocatorCreateInfo::device."]
#[doc = ""]
#[doc = "When this flag is used, VmaAllocationCreateInfo::priority and VmaPoolCreateInfo::priority"]
#[doc = "are used to set priorities of allocated Vulkan memory. Without it, these variables are ignored."]
#[doc = ""]
#[doc = "A priority must be a floating-point value between 0 and 1, indicating the priority of the allocation relative to other memory allocations."]
#[doc = "Larger values are higher priority. The granularity of the priorities is implementation-dependent."]
#[doc = "It is automatically passed to every call to `vkAllocateMemory` done by the library using structure `VkMemoryPriorityAllocateInfoEXT`."]
#[doc = "The value to be used for default priority is 0.5."]
#[doc = "For more details, see the documentation of the VK_EXT_memory_priority extension."]
pub const VmaAllocatorCreateFlagBits_VMA_ALLOCATOR_CREATE_EXT_MEMORY_PRIORITY_BIT:
    VmaAllocatorCreateFlagBits = 64;
#[doc = "Enables usage of VK_EXT_memory_priority extension in the library."]
#[doc = ""]
#[doc = "You may set this flag only if you found available and enabled this device extension,"]
#[doc = "along with `VkPhysicalDeviceMemoryPriorityFeaturesEXT::memoryPriority == VK_TRUE`,"]
#[doc = "while creating Vulkan device passed as VmaAllocatorCreateInfo::device."]
#[doc = ""]
#[doc = "When this flag is used, VmaAllocationCreateInfo::priority and VmaPoolCreateInfo::priority"]
#[doc = "are used to set priorities of allocated Vulkan memory. Without it, these variables are ignored."]
#[doc = ""]
#[doc = "A priority must be a floating-point value between 0 and 1, indicating the priority of the allocation relative to other memory allocations."]
#[doc = "Larger values are higher priority. The granularity of the priorities is implementation-dependent."]
#[doc = "It is automatically passed to every call to `vkAllocateMemory` done by the library using structure `VkMemoryPriorityAllocateInfoEXT`."]
#[doc = "The value to be used for default priority is 0.5."]
#[doc = "For more details, see the documentation of the VK_EXT_memory_priority extension."]
pub const VmaAllocatorCreateFlagBits_VMA_ALLOCATOR_CREATE_FLAG_BITS_MAX_ENUM:
    VmaAllocatorCreateFlagBits = 2147483647;
#[doc = " Flags for created #VmaAllocator."]
pub type VmaAllocatorCreateFlagBits = ::std::os::raw::c_uint;
#[doc = " See #VmaAllocatorCreateFlagBits."]
pub type VmaAllocatorCreateFlags = VkFlags;
#[doc = " No intended memory usage specified."]
#[doc = "Use other members of VmaAllocationCreateInfo to specify your requirements."]
pub const VmaMemoryUsage_VMA_MEMORY_USAGE_UNKNOWN: VmaMemoryUsage = 0;
#[doc = "\\deprecated Obsolete, preserved for backward compatibility."]
#[doc = "Prefers `VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT`."]
pub const VmaMemoryUsage_VMA_MEMORY_USAGE_GPU_ONLY: VmaMemoryUsage = 1;
#[doc = "\\deprecated Obsolete, preserved for backward compatibility."]
#[doc = "Guarantees `VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT` and `VK_MEMORY_PROPERTY_HOST_COHERENT_BIT`."]
pub const VmaMemoryUsage_VMA_MEMORY_USAGE_CPU_ONLY: VmaMemoryUsage = 2;
#[doc = "\\deprecated Obsolete, preserved for backward compatibility."]
#[doc = "Guarantees `VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT`, prefers `VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT`."]
pub const VmaMemoryUsage_VMA_MEMORY_USAGE_CPU_TO_GPU: VmaMemoryUsage = 3;
#[doc = "\\deprecated Obsolete, preserved for backward compatibility."]
#[doc = "Guarantees `VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT`, prefers `VK_MEMORY_PROPERTY_HOST_CACHED_BIT`."]
pub const VmaMemoryUsage_VMA_MEMORY_USAGE_GPU_TO_CPU: VmaMemoryUsage = 4;
#[doc = "\\deprecated Obsolete, preserved for backward compatibility."]
#[doc = "Prefers not `VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT`."]
pub const VmaMemoryUsage_VMA_MEMORY_USAGE_CPU_COPY: VmaMemoryUsage = 5;
#[doc = "Lazily allocated GPU memory having `VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT`."]
#[doc = "Exists mostly on mobile platforms. Using it on desktop PC or other GPUs with no such memory type present will fail the allocation."]
#[doc = ""]
#[doc = "Usage: Memory for transient attachment images (color attachments, depth attachments etc.), created with `VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT`."]
#[doc = ""]
#[doc = "Allocations with this usage are always created as dedicated - it implies #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT."]
pub const VmaMemoryUsage_VMA_MEMORY_USAGE_GPU_LAZILY_ALLOCATED: VmaMemoryUsage = 6;
#[doc = "Selects best memory type automatically."]
#[doc = "This flag is recommended for most common use cases."]
#[doc = ""]
#[doc = "When using this flag, if you want to map the allocation (using vmaMapMemory() or #VMA_ALLOCATION_CREATE_MAPPED_BIT),"]
#[doc = "you must pass one of the flags: #VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT or #VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT"]
#[doc = "in VmaAllocationCreateInfo::flags."]
#[doc = ""]
#[doc = "It can be used only with functions that let the library know `VkBufferCreateInfo` or `VkImageCreateInfo`, e.g."]
#[doc = "vmaCreateBuffer(), vmaCreateImage(), vmaFindMemoryTypeIndexForBufferInfo(), vmaFindMemoryTypeIndexForImageInfo()"]
#[doc = "and not with generic memory allocation functions."]
pub const VmaMemoryUsage_VMA_MEMORY_USAGE_AUTO: VmaMemoryUsage = 7;
#[doc = "Selects best memory type automatically with preference for GPU (device) memory."]
#[doc = ""]
#[doc = "When using this flag, if you want to map the allocation (using vmaMapMemory() or #VMA_ALLOCATION_CREATE_MAPPED_BIT),"]
#[doc = "you must pass one of the flags: #VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT or #VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT"]
#[doc = "in VmaAllocationCreateInfo::flags."]
#[doc = ""]
#[doc = "It can be used only with functions that let the library know `VkBufferCreateInfo` or `VkImageCreateInfo`, e.g."]
#[doc = "vmaCreateBuffer(), vmaCreateImage(), vmaFindMemoryTypeIndexForBufferInfo(), vmaFindMemoryTypeIndexForImageInfo()"]
#[doc = "and not with generic memory allocation functions."]
pub const VmaMemoryUsage_VMA_MEMORY_USAGE_AUTO_PREFER_DEVICE: VmaMemoryUsage = 8;
#[doc = "Selects best memory type automatically with preference for CPU (host) memory."]
#[doc = ""]
#[doc = "When using this flag, if you want to map the allocation (using vmaMapMemory() or #VMA_ALLOCATION_CREATE_MAPPED_BIT),"]
#[doc = "you must pass one of the flags: #VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT or #VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT"]
#[doc = "in VmaAllocationCreateInfo::flags."]
#[doc = ""]
#[doc = "It can be used only with functions that let the library know `VkBufferCreateInfo` or `VkImageCreateInfo`, e.g."]
#[doc = "vmaCreateBuffer(), vmaCreateImage(), vmaFindMemoryTypeIndexForBufferInfo(), vmaFindMemoryTypeIndexForImageInfo()"]
#[doc = "and not with generic memory allocation functions."]
pub const VmaMemoryUsage_VMA_MEMORY_USAGE_AUTO_PREFER_HOST: VmaMemoryUsage = 9;
#[doc = "Selects best memory type automatically with preference for CPU (host) memory."]
#[doc = ""]
#[doc = "When using this flag, if you want to map the allocation (using vmaMapMemory() or #VMA_ALLOCATION_CREATE_MAPPED_BIT),"]
#[doc = "you must pass one of the flags: #VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT or #VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT"]
#[doc = "in VmaAllocationCreateInfo::flags."]
#[doc = ""]
#[doc = "It can be used only with functions that let the library know `VkBufferCreateInfo` or `VkImageCreateInfo`, e.g."]
#[doc = "vmaCreateBuffer(), vmaCreateImage(), vmaFindMemoryTypeIndexForBufferInfo(), vmaFindMemoryTypeIndexForImageInfo()"]
#[doc = "and not with generic memory allocation functions."]
pub const VmaMemoryUsage_VMA_MEMORY_USAGE_MAX_ENUM: VmaMemoryUsage = 2147483647;
#[doc = " \\brief Intended usage of the allocated memory."]
pub type VmaMemoryUsage = ::std::os::raw::c_uint;
#[doc = " \\brief Set this flag if the allocation should have its own memory block."]
#[doc = ""]
#[doc = "Use it for special, big resources, like fullscreen images used as attachments."]
pub const VmaAllocationCreateFlagBits_VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT:
    VmaAllocationCreateFlagBits = 1;
#[doc = " \\brief Set this flag to only try to allocate from existing `VkDeviceMemory` blocks and never create new such block."]
#[doc = ""]
#[doc = "If new allocation cannot be placed in any of the existing blocks, allocation"]
#[doc = "fails with `VK_ERROR_OUT_OF_DEVICE_MEMORY` error."]
#[doc = ""]
#[doc = "You should not use #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT and"]
#[doc = "#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT at the same time. It makes no sense."]
pub const VmaAllocationCreateFlagBits_VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT:
    VmaAllocationCreateFlagBits = 2;
#[doc = " \\brief Set this flag to use a memory that will be persistently mapped and retrieve pointer to it."]
#[doc = ""]
#[doc = "Pointer to mapped memory will be returned through VmaAllocationInfo::pMappedData."]
#[doc = ""]
#[doc = "It is valid to use this flag for allocation made from memory type that is not"]
#[doc = "`HOST_VISIBLE`. This flag is then ignored and memory is not mapped. This is"]
#[doc = "useful if you need an allocation that is efficient to use on GPU"]
#[doc = "(`DEVICE_LOCAL`) and still want to map it directly if possible on platforms that"]
#[doc = "support it (e.g. Intel GPU)."]
pub const VmaAllocationCreateFlagBits_VMA_ALLOCATION_CREATE_MAPPED_BIT:
    VmaAllocationCreateFlagBits = 4;
#[doc = " \\deprecated Preserved for backward compatibility. Consider using vmaSetAllocationName() instead."]
#[doc = ""]
#[doc = "Set this flag to treat VmaAllocationCreateInfo::pUserData as pointer to a"]
#[doc = "null-terminated string. Instead of copying pointer value, a local copy of the"]
#[doc = "string is made and stored in allocation's `pName`. The string is automatically"]
#[doc = "freed together with the allocation. It is also used in vmaBuildStatsString()."]
pub const VmaAllocationCreateFlagBits_VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT:
    VmaAllocationCreateFlagBits = 32;
#[doc = " Allocation will be created from upper stack in a double stack pool."]
#[doc = ""]
#[doc = "This flag is only allowed for custom pools created with #VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT flag."]
pub const VmaAllocationCreateFlagBits_VMA_ALLOCATION_CREATE_UPPER_ADDRESS_BIT:
    VmaAllocationCreateFlagBits = 64;
#[doc = " Create both buffer/image and allocation, but don't bind them together."]
#[doc = "It is useful when you want to bind yourself to do some more advanced binding, e.g. using some extensions."]
#[doc = "The flag is meaningful only with functions that bind by default: vmaCreateBuffer(), vmaCreateImage()."]
#[doc = "Otherwise it is ignored."]
#[doc = ""]
#[doc = "If you want to make sure the new buffer/image is not tied to the new memory allocation"]
#[doc = "through `VkMemoryDedicatedAllocateInfoKHR` structure in case the allocation ends up in its own memory block,"]
#[doc = "use also flag #VMA_ALLOCATION_CREATE_CAN_ALIAS_BIT."]
pub const VmaAllocationCreateFlagBits_VMA_ALLOCATION_CREATE_DONT_BIND_BIT:
    VmaAllocationCreateFlagBits = 128;
#[doc = " Create allocation only if additional device memory required for it, if any, won't exceed"]
#[doc = "memory budget. Otherwise return `VK_ERROR_OUT_OF_DEVICE_MEMORY`."]
pub const VmaAllocationCreateFlagBits_VMA_ALLOCATION_CREATE_WITHIN_BUDGET_BIT:
    VmaAllocationCreateFlagBits = 256;
#[doc = " \\brief Set this flag if the allocated memory will have aliasing resources."]
#[doc = ""]
#[doc = "Usage of this flag prevents supplying `VkMemoryDedicatedAllocateInfoKHR` when #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT is specified."]
#[doc = "Otherwise created dedicated memory will not be suitable for aliasing resources, resulting in Vulkan Validation Layer errors."]
pub const VmaAllocationCreateFlagBits_VMA_ALLOCATION_CREATE_CAN_ALIAS_BIT:
    VmaAllocationCreateFlagBits = 512;
#[doc = "Requests possibility to map the allocation (using vmaMapMemory() or #VMA_ALLOCATION_CREATE_MAPPED_BIT)."]
#[doc = ""]
#[doc = "- If you use #VMA_MEMORY_USAGE_AUTO or other `VMA_MEMORY_USAGE_AUTO*` value,"]
#[doc = "you must use this flag to be able to map the allocation. Otherwise, mapping is incorrect."]
#[doc = "- If you use other value of #VmaMemoryUsage, this flag is ignored and mapping is always possible in memory types that are `HOST_VISIBLE`."]
#[doc = "This includes allocations created in \\ref custom_memory_pools."]
#[doc = ""]
#[doc = "Declares that mapped memory will only be written sequentially, e.g. using `memcpy()` or a loop writing number-by-number,"]
#[doc = "never read or accessed randomly, so a memory type can be selected that is uncached and write-combined."]
#[doc = ""]
#[doc = "\\warning Violating this declaration may work correctly, but will likely be very slow."]
#[doc = "Watch out for implicit reads introduced by doing e.g. `pMappedData[i] += x;`"]
#[doc = "Better prepare your data in a local variable and `memcpy()` it to the mapped pointer all at once."]
pub const VmaAllocationCreateFlagBits_VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT:
    VmaAllocationCreateFlagBits = 1024;
#[doc = "Requests possibility to map the allocation (using vmaMapMemory() or #VMA_ALLOCATION_CREATE_MAPPED_BIT)."]
#[doc = ""]
#[doc = "- If you use #VMA_MEMORY_USAGE_AUTO or other `VMA_MEMORY_USAGE_AUTO*` value,"]
#[doc = "you must use this flag to be able to map the allocation. Otherwise, mapping is incorrect."]
#[doc = "- If you use other value of #VmaMemoryUsage, this flag is ignored and mapping is always possible in memory types that are `HOST_VISIBLE`."]
#[doc = "This includes allocations created in \\ref custom_memory_pools."]
#[doc = ""]
#[doc = "Declares that mapped memory can be read, written, and accessed in random order,"]
#[doc = "so a `HOST_CACHED` memory type is required."]
pub const VmaAllocationCreateFlagBits_VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT:
    VmaAllocationCreateFlagBits = 2048;
#[doc = "Together with #VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT or #VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT,"]
#[doc = "it says that despite request for host access, a not-`HOST_VISIBLE` memory type can be selected"]
#[doc = "if it may improve performance."]
#[doc = ""]
#[doc = "By using this flag, you declare that you will check if the allocation ended up in a `HOST_VISIBLE` memory type"]
#[doc = "(e.g. using vmaGetAllocationMemoryProperties()) and if not, you will create some \"staging\" buffer and"]
#[doc = "issue an explicit transfer to write/read your data."]
#[doc = "To prepare for this possibility, don't forget to add appropriate flags like"]
#[doc = "`VK_BUFFER_USAGE_TRANSFER_DST_BIT`, `VK_BUFFER_USAGE_TRANSFER_SRC_BIT` to the parameters of created buffer or image."]
pub const VmaAllocationCreateFlagBits_VMA_ALLOCATION_CREATE_HOST_ACCESS_ALLOW_TRANSFER_INSTEAD_BIT : VmaAllocationCreateFlagBits = 4096 ;
#[doc = " Allocation strategy that chooses smallest possible free range for the allocation"]
#[doc = "to minimize memory usage and fragmentation, possibly at the expense of allocation time."]
pub const VmaAllocationCreateFlagBits_VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT:
    VmaAllocationCreateFlagBits = 65536;
#[doc = " Allocation strategy that chooses first suitable free range for the allocation -"]
#[doc = "not necessarily in terms of the smallest offset but the one that is easiest and fastest to find"]
#[doc = "to minimize allocation time, possibly at the expense of allocation quality."]
pub const VmaAllocationCreateFlagBits_VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT:
    VmaAllocationCreateFlagBits = 131072;
#[doc = " Allocation strategy that chooses always the lowest offset in available space."]
#[doc = "This is not the most efficient strategy but achieves highly packed data."]
#[doc = "Used internally by defragmentation, not recomended in typical usage."]
pub const VmaAllocationCreateFlagBits_VMA_ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT:
    VmaAllocationCreateFlagBits = 262144;
#[doc = " Alias to #VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT."]
pub const VmaAllocationCreateFlagBits_VMA_ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT:
    VmaAllocationCreateFlagBits = 65536;
#[doc = " Alias to #VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT."]
pub const VmaAllocationCreateFlagBits_VMA_ALLOCATION_CREATE_STRATEGY_FIRST_FIT_BIT:
    VmaAllocationCreateFlagBits = 131072;
#[doc = " A bit mask to extract only `STRATEGY` bits from entire set of flags."]
pub const VmaAllocationCreateFlagBits_VMA_ALLOCATION_CREATE_STRATEGY_MASK:
    VmaAllocationCreateFlagBits = 458752;
#[doc = " A bit mask to extract only `STRATEGY` bits from entire set of flags."]
pub const VmaAllocationCreateFlagBits_VMA_ALLOCATION_CREATE_FLAG_BITS_MAX_ENUM:
    VmaAllocationCreateFlagBits = 2147483647;
#[doc = " Flags to be passed as VmaAllocationCreateInfo::flags."]
pub type VmaAllocationCreateFlagBits = ::std::os::raw::c_uint;
#[doc = " See #VmaAllocationCreateFlagBits."]
pub type VmaAllocationCreateFlags = VkFlags;
#[doc = " \\brief Use this flag if you always allocate only buffers and linear images or only optimal images out of this pool and so Buffer-Image Granularity can be ignored."]
#[doc = ""]
#[doc = "This is an optional optimization flag."]
#[doc = ""]
#[doc = "If you always allocate using vmaCreateBuffer(), vmaCreateImage(),"]
#[doc = "vmaAllocateMemoryForBuffer(), then you don't need to use it because allocator"]
#[doc = "knows exact type of your allocations so it can handle Buffer-Image Granularity"]
#[doc = "in the optimal way."]
#[doc = ""]
#[doc = "If you also allocate using vmaAllocateMemoryForImage() or vmaAllocateMemory(),"]
#[doc = "exact type of such allocations is not known, so allocator must be conservative"]
#[doc = "in handling Buffer-Image Granularity, which can lead to suboptimal allocation"]
#[doc = "(wasted memory). In that case, if you can make sure you always allocate only"]
#[doc = "buffers and linear images or only optimal images out of this pool, use this flag"]
#[doc = "to make allocator disregard Buffer-Image Granularity and so make allocations"]
#[doc = "faster and more optimal."]
pub const VmaPoolCreateFlagBits_VMA_POOL_CREATE_IGNORE_BUFFER_IMAGE_GRANULARITY_BIT:
    VmaPoolCreateFlagBits = 2;
#[doc = " \\brief Enables alternative, linear allocation algorithm in this pool."]
#[doc = ""]
#[doc = "Specify this flag to enable linear allocation algorithm, which always creates"]
#[doc = "new allocations after last one and doesn't reuse space from allocations freed in"]
#[doc = "between. It trades memory consumption for simplified algorithm and data"]
#[doc = "structure, which has better performance and uses less memory for metadata."]
#[doc = ""]
#[doc = "By using this flag, you can achieve behavior of free-at-once, stack,"]
#[doc = "ring buffer, and double stack."]
#[doc = "For details, see documentation chapter \\ref linear_algorithm."]
pub const VmaPoolCreateFlagBits_VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT: VmaPoolCreateFlagBits = 4;
#[doc = " Bit mask to extract only `ALGORITHM` bits from entire set of flags."]
pub const VmaPoolCreateFlagBits_VMA_POOL_CREATE_ALGORITHM_MASK: VmaPoolCreateFlagBits = 4;
#[doc = " Bit mask to extract only `ALGORITHM` bits from entire set of flags."]
pub const VmaPoolCreateFlagBits_VMA_POOL_CREATE_FLAG_BITS_MAX_ENUM: VmaPoolCreateFlagBits =
    2147483647;
#[doc = " Flags to be passed as VmaPoolCreateInfo::flags."]
pub type VmaPoolCreateFlagBits = ::std::os::raw::c_uint;
#[doc = " Flags to be passed as VmaPoolCreateInfo::flags. See #VmaPoolCreateFlagBits."]
pub type VmaPoolCreateFlags = VkFlags;
pub const VmaDefragmentationFlagBits_VMA_DEFRAGMENTATION_FLAG_ALGORITHM_FAST_BIT:
    VmaDefragmentationFlagBits = 1;
pub const VmaDefragmentationFlagBits_VMA_DEFRAGMENTATION_FLAG_ALGORITHM_BALANCED_BIT:
    VmaDefragmentationFlagBits = 2;
pub const VmaDefragmentationFlagBits_VMA_DEFRAGMENTATION_FLAG_ALGORITHM_FULL_BIT:
    VmaDefragmentationFlagBits = 4;
#[doc = " \\brief Use the most roboust algorithm at the cost of time to compute and number of copies to make."]
#[doc = "Only available when bufferImageGranularity is greater than 1, since it aims to reduce"]
#[doc = "alignment issues between different types of resources."]
#[doc = "Otherwise falls back to same behavior as #VMA_DEFRAGMENTATION_FLAG_ALGORITHM_FULL_BIT."]
pub const VmaDefragmentationFlagBits_VMA_DEFRAGMENTATION_FLAG_ALGORITHM_EXTENSIVE_BIT:
    VmaDefragmentationFlagBits = 8;
#[doc = " A bit mask to extract only `ALGORITHM` bits from entire set of flags."]
pub const VmaDefragmentationFlagBits_VMA_DEFRAGMENTATION_FLAG_ALGORITHM_MASK:
    VmaDefragmentationFlagBits = 15;
#[doc = " A bit mask to extract only `ALGORITHM` bits from entire set of flags."]
pub const VmaDefragmentationFlagBits_VMA_DEFRAGMENTATION_FLAG_BITS_MAX_ENUM:
    VmaDefragmentationFlagBits = 2147483647;
#[doc = " Flags to be passed as VmaDefragmentationInfo::flags."]
pub type VmaDefragmentationFlagBits = ::std::os::raw::c_uint;
#[doc = " See #VmaDefragmentationFlagBits."]
pub type VmaDefragmentationFlags = VkFlags;
#[doc = " Buffer/image has been recreated at `dstTmpAllocation`, data has been copied, old buffer/image has been destroyed. `srcAllocation` should be changed to point to the new place. This is the default value set by vmaBeginDefragmentationPass()."]
pub const VmaDefragmentationMoveOperation_VMA_DEFRAGMENTATION_MOVE_OPERATION_COPY:
    VmaDefragmentationMoveOperation = 0;
#[doc = " Set this value if you cannot move the allocation. New place reserved at `dstTmpAllocation` will be freed. `srcAllocation` will remain unchanged."]
pub const VmaDefragmentationMoveOperation_VMA_DEFRAGMENTATION_MOVE_OPERATION_IGNORE:
    VmaDefragmentationMoveOperation = 1;
#[doc = " Set this value if you decide to abandon the allocation and you destroyed the buffer/image. New place reserved at `dstTmpAllocation` will be freed, along with `srcAllocation`, which will be destroyed."]
pub const VmaDefragmentationMoveOperation_VMA_DEFRAGMENTATION_MOVE_OPERATION_DESTROY:
    VmaDefragmentationMoveOperation = 2;
#[doc = " Operation performed on single defragmentation move. See structure #VmaDefragmentationMove."]
pub type VmaDefragmentationMoveOperation = ::std::os::raw::c_uint;
#[doc = " \\brief Enables alternative, linear allocation algorithm in this virtual block."]
#[doc = ""]
#[doc = "Specify this flag to enable linear allocation algorithm, which always creates"]
#[doc = "new allocations after last one and doesn't reuse space from allocations freed in"]
#[doc = "between. It trades memory consumption for simplified algorithm and data"]
#[doc = "structure, which has better performance and uses less memory for metadata."]
#[doc = ""]
#[doc = "By using this flag, you can achieve behavior of free-at-once, stack,"]
#[doc = "ring buffer, and double stack."]
#[doc = "For details, see documentation chapter \\ref linear_algorithm."]
pub const VmaVirtualBlockCreateFlagBits_VMA_VIRTUAL_BLOCK_CREATE_LINEAR_ALGORITHM_BIT:
    VmaVirtualBlockCreateFlagBits = 1;
#[doc = " \\brief Bit mask to extract only `ALGORITHM` bits from entire set of flags."]
pub const VmaVirtualBlockCreateFlagBits_VMA_VIRTUAL_BLOCK_CREATE_ALGORITHM_MASK:
    VmaVirtualBlockCreateFlagBits = 1;
#[doc = " \\brief Bit mask to extract only `ALGORITHM` bits from entire set of flags."]
pub const VmaVirtualBlockCreateFlagBits_VMA_VIRTUAL_BLOCK_CREATE_FLAG_BITS_MAX_ENUM:
    VmaVirtualBlockCreateFlagBits = 2147483647;
#[doc = " Flags to be passed as VmaVirtualBlockCreateInfo::flags."]
pub type VmaVirtualBlockCreateFlagBits = ::std::os::raw::c_uint;
#[doc = " Flags to be passed as VmaVirtualBlockCreateInfo::flags. See #VmaVirtualBlockCreateFlagBits."]
pub type VmaVirtualBlockCreateFlags = VkFlags;
#[doc = " \\brief Allocation will be created from upper stack in a double stack pool."]
#[doc = ""]
#[doc = "This flag is only allowed for virtual blocks created with #VMA_VIRTUAL_BLOCK_CREATE_LINEAR_ALGORITHM_BIT flag."]
pub const VmaVirtualAllocationCreateFlagBits_VMA_VIRTUAL_ALLOCATION_CREATE_UPPER_ADDRESS_BIT:
    VmaVirtualAllocationCreateFlagBits = 64;
#[doc = " \\brief Allocation strategy that tries to minimize memory usage."]
pub const VmaVirtualAllocationCreateFlagBits_VMA_VIRTUAL_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT : VmaVirtualAllocationCreateFlagBits = 65536 ;
#[doc = " \\brief Allocation strategy that tries to minimize allocation time."]
pub const VmaVirtualAllocationCreateFlagBits_VMA_VIRTUAL_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT:
    VmaVirtualAllocationCreateFlagBits = 131072;
#[doc = " Allocation strategy that chooses always the lowest offset in available space."]
#[doc = "This is not the most efficient strategy but achieves highly packed data."]
pub const VmaVirtualAllocationCreateFlagBits_VMA_VIRTUAL_ALLOCATION_CREATE_STRATEGY_MIN_OFFSET_BIT : VmaVirtualAllocationCreateFlagBits = 262144 ;
#[doc = " \\brief A bit mask to extract only `STRATEGY` bits from entire set of flags."]
#[doc = ""]
#[doc = "These strategy flags are binary compatible with equivalent flags in #VmaAllocationCreateFlagBits."]
pub const VmaVirtualAllocationCreateFlagBits_VMA_VIRTUAL_ALLOCATION_CREATE_STRATEGY_MASK:
    VmaVirtualAllocationCreateFlagBits = 458752;
#[doc = " \\brief A bit mask to extract only `STRATEGY` bits from entire set of flags."]
#[doc = ""]
#[doc = "These strategy flags are binary compatible with equivalent flags in #VmaAllocationCreateFlagBits."]
pub const VmaVirtualAllocationCreateFlagBits_VMA_VIRTUAL_ALLOCATION_CREATE_FLAG_BITS_MAX_ENUM:
    VmaVirtualAllocationCreateFlagBits = 2147483647;
#[doc = " Flags to be passed as VmaVirtualAllocationCreateInfo::flags."]
pub type VmaVirtualAllocationCreateFlagBits = ::std::os::raw::c_uint;
#[doc = " Flags to be passed as VmaVirtualAllocationCreateInfo::flags. See #VmaVirtualAllocationCreateFlagBits."]
pub type VmaVirtualAllocationCreateFlags = VkFlags;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VmaAllocator_T {
    _unused: [u8; 0],
}
pub type VmaAllocator = *mut VmaAllocator_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VmaPool_T {
    _unused: [u8; 0],
}
pub type VmaPool = *mut VmaPool_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VmaAllocation_T {
    _unused: [u8; 0],
}
pub type VmaAllocation = *mut VmaAllocation_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VmaDefragmentationContext_T {
    _unused: [u8; 0],
}
pub type VmaDefragmentationContext = *mut VmaDefragmentationContext_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VmaVirtualAllocation_T {
    _unused: [u8; 0],
}
pub type VmaVirtualAllocation = *mut VmaVirtualAllocation_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VmaVirtualBlock_T {
    _unused: [u8; 0],
}
pub type VmaVirtualBlock = *mut VmaVirtualBlock_T;
#[doc = " Callback function called after successful vkAllocateMemory."]
pub type PFN_vmaAllocateDeviceMemoryFunction = ::std::option::Option<
    unsafe extern "C" fn(
        allocator: VmaAllocator,
        memoryType: u32,
        memory: VkDeviceMemory,
        size: VkDeviceSize,
        pUserData: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " Callback function called before vkFreeMemory."]
pub type PFN_vmaFreeDeviceMemoryFunction = ::std::option::Option<
    unsafe extern "C" fn(
        allocator: VmaAllocator,
        memoryType: u32,
        memory: VkDeviceMemory,
        size: VkDeviceSize,
        pUserData: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " \\brief Set of callbacks that the library will call for `vkAllocateMemory` and `vkFreeMemory`."]
#[doc = ""]
#[doc = "Provided for informative purpose, e.g. to gather statistics about number of"]
#[doc = "allocations or total amount of memory allocated in Vulkan."]
#[doc = ""]
#[doc = "Used in VmaAllocatorCreateInfo::pDeviceMemoryCallbacks."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VmaDeviceMemoryCallbacks {
    #[doc = " Optional, can be null."]
    pub pfnAllocate: PFN_vmaAllocateDeviceMemoryFunction,
    #[doc = " Optional, can be null."]
    pub pfnFree: PFN_vmaFreeDeviceMemoryFunction,
    #[doc = " Optional, can be null."]
    pub pUserData: *mut ::std::os::raw::c_void,
}
impl Default for VmaDeviceMemoryCallbacks {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief Pointers to some Vulkan functions - a subset used by the library."]
#[doc = ""]
#[doc = "Used in VmaAllocatorCreateInfo::pVulkanFunctions."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VmaVulkanFunctions {
    #[doc = " Required when using VMA_DYNAMIC_VULKAN_FUNCTIONS."]
    pub vkGetInstanceProcAddr: PFN_vkGetInstanceProcAddr,
    #[doc = " Required when using VMA_DYNAMIC_VULKAN_FUNCTIONS."]
    pub vkGetDeviceProcAddr: PFN_vkGetDeviceProcAddr,
    pub vkGetPhysicalDeviceProperties: PFN_vkGetPhysicalDeviceProperties,
    pub vkGetPhysicalDeviceMemoryProperties: PFN_vkGetPhysicalDeviceMemoryProperties,
    pub vkAllocateMemory: PFN_vkAllocateMemory,
    pub vkFreeMemory: PFN_vkFreeMemory,
    pub vkMapMemory: PFN_vkMapMemory,
    pub vkUnmapMemory: PFN_vkUnmapMemory,
    pub vkFlushMappedMemoryRanges: PFN_vkFlushMappedMemoryRanges,
    pub vkInvalidateMappedMemoryRanges: PFN_vkInvalidateMappedMemoryRanges,
    pub vkBindBufferMemory: PFN_vkBindBufferMemory,
    pub vkBindImageMemory: PFN_vkBindImageMemory,
    pub vkGetBufferMemoryRequirements: PFN_vkGetBufferMemoryRequirements,
    pub vkGetImageMemoryRequirements: PFN_vkGetImageMemoryRequirements,
    pub vkCreateBuffer: PFN_vkCreateBuffer,
    pub vkDestroyBuffer: PFN_vkDestroyBuffer,
    pub vkCreateImage: PFN_vkCreateImage,
    pub vkDestroyImage: PFN_vkDestroyImage,
    pub vkCmdCopyBuffer: PFN_vkCmdCopyBuffer,
    #[doc = " Fetch \"vkGetBufferMemoryRequirements2\" on Vulkan >= 1.1, fetch \"vkGetBufferMemoryRequirements2KHR\" when using VK_KHR_dedicated_allocation extension."]
    pub vkGetBufferMemoryRequirements2KHR: PFN_vkGetBufferMemoryRequirements2KHR,
    #[doc = " Fetch \"vkGetImageMemoryRequirements2\" on Vulkan >= 1.1, fetch \"vkGetImageMemoryRequirements2KHR\" when using VK_KHR_dedicated_allocation extension."]
    pub vkGetImageMemoryRequirements2KHR: PFN_vkGetImageMemoryRequirements2KHR,
    #[doc = " Fetch \"vkBindBufferMemory2\" on Vulkan >= 1.1, fetch \"vkBindBufferMemory2KHR\" when using VK_KHR_bind_memory2 extension."]
    pub vkBindBufferMemory2KHR: PFN_vkBindBufferMemory2KHR,
    #[doc = " Fetch \"vkBindImageMemory2\" on Vulkan >= 1.1, fetch \"vkBindImageMemory2KHR\" when using VK_KHR_bind_memory2 extension."]
    pub vkBindImageMemory2KHR: PFN_vkBindImageMemory2KHR,
    pub vkGetPhysicalDeviceMemoryProperties2KHR: PFN_vkGetPhysicalDeviceMemoryProperties2KHR,
    #[doc = " Fetch from \"vkGetDeviceBufferMemoryRequirements\" on Vulkan >= 1.3, but you can also fetch it from \"vkGetDeviceBufferMemoryRequirementsKHR\" if you enabled extension VK_KHR_maintenance4."]
    pub vkGetDeviceBufferMemoryRequirements: PFN_vkGetDeviceBufferMemoryRequirements,
    #[doc = " Fetch from \"vkGetDeviceImageMemoryRequirements\" on Vulkan >= 1.3, but you can also fetch it from \"vkGetDeviceImageMemoryRequirementsKHR\" if you enabled extension VK_KHR_maintenance4."]
    pub vkGetDeviceImageMemoryRequirements: PFN_vkGetDeviceImageMemoryRequirements,
}
#[doc = " Description of a Allocator to be created."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VmaAllocatorCreateInfo {
    #[doc = " Flags for created allocator. Use #VmaAllocatorCreateFlagBits enum."]
    pub flags: VmaAllocatorCreateFlags,
    #[doc = " Vulkan physical device."]
    #[doc = "** It must be valid throughout whole lifetime of created allocator. */"]
    pub physicalDevice: VkPhysicalDevice,
    #[doc = " Vulkan device."]
    #[doc = "** It must be valid throughout whole lifetime of created allocator. */"]
    pub device: VkDevice,
    #[doc = " Preferred size of a single `VkDeviceMemory` block to be allocated from large heaps > 1 GiB. Optional."]
    #[doc = "** Set to 0 to use default, which is currently 256 MiB. */"]
    pub preferredLargeHeapBlockSize: VkDeviceSize,
    #[doc = " Custom CPU memory allocation callbacks. Optional."]
    #[doc = "** Optional, can be null. When specified, will also be used for all CPU-side memory allocations. */"]
    pub pAllocationCallbacks: *const VkAllocationCallbacks,
    #[doc = " Informative callbacks for `vkAllocateMemory`, `vkFreeMemory`. Optional."]
    #[doc = "** Optional, can be null. */"]
    pub pDeviceMemoryCallbacks: *const VmaDeviceMemoryCallbacks,
    #[doc = " \\brief Either null or a pointer to an array of limits on maximum number of bytes that can be allocated out of particular Vulkan memory heap."]
    #[doc = ""]
    #[doc = "If not NULL, it must be a pointer to an array of"]
    #[doc = "`VkPhysicalDeviceMemoryProperties::memoryHeapCount` elements, defining limit on"]
    #[doc = "maximum number of bytes that can be allocated out of particular Vulkan memory"]
    #[doc = "heap."]
    #[doc = ""]
    #[doc = "Any of the elements may be equal to `VK_WHOLE_SIZE`, which means no limit on that"]
    #[doc = "heap. This is also the default in case of `pHeapSizeLimit` = NULL."]
    #[doc = ""]
    #[doc = "If there is a limit defined for a heap:"]
    #[doc = ""]
    #[doc = "- If user tries to allocate more memory from that heap using this allocator,"]
    #[doc = "the allocation fails with `VK_ERROR_OUT_OF_DEVICE_MEMORY`."]
    #[doc = "- If the limit is smaller than heap size reported in `VkMemoryHeap::size`, the"]
    #[doc = "value of this limit will be reported instead when using vmaGetMemoryProperties()."]
    #[doc = ""]
    #[doc = "Warning! Using this feature may not be equivalent to installing a GPU with"]
    #[doc = "smaller amount of memory, because graphics driver doesn't necessary fail new"]
    #[doc = "allocations with `VK_ERROR_OUT_OF_DEVICE_MEMORY` result when memory capacity is"]
    #[doc = "exceeded. It may return success and just silently migrate some device memory"]
    #[doc = "blocks to system RAM. This driver behavior can also be controlled using"]
    #[doc = "VK_AMD_memory_overallocation_behavior extension."]
    pub pHeapSizeLimit: *const VkDeviceSize,
    #[doc = " \\brief Pointers to Vulkan functions. Can be null."]
    #[doc = ""]
    #[doc = "For details see [Pointers to Vulkan functions](@ref config_Vulkan_functions)."]
    pub pVulkanFunctions: *const VmaVulkanFunctions,
    #[doc = " \\brief Handle to Vulkan instance object."]
    #[doc = ""]
    #[doc = "Starting from version 3.0.0 this member is no longer optional, it must be set!"]
    pub instance: VkInstance,
    #[doc = " \\brief Optional. The highest version of Vulkan that the application is designed to use."]
    #[doc = ""]
    #[doc = "It must be a value in the format as created by macro `VK_MAKE_VERSION` or a constant like: `VK_API_VERSION_1_1`, `VK_API_VERSION_1_0`."]
    #[doc = "The patch version number specified is ignored. Only the major and minor versions are considered."]
    #[doc = "It must be less or equal (preferably equal) to value as passed to `vkCreateInstance` as `VkApplicationInfo::apiVersion`."]
    #[doc = "Only versions 1.0, 1.1, 1.2, 1.3 are supported by the current implementation."]
    #[doc = "Leaving it initialized to zero is equivalent to `VK_API_VERSION_1_0`."]
    pub vulkanApiVersion: u32,
    #[doc = " \\brief Either null or a pointer to an array of external memory handle types for each Vulkan memory type."]
    #[doc = ""]
    #[doc = "If not NULL, it must be a pointer to an array of `VkPhysicalDeviceMemoryProperties::memoryTypeCount`"]
    #[doc = "elements, defining external memory handle types of particular Vulkan memory type,"]
    #[doc = "to be passed using `VkExportMemoryAllocateInfoKHR`."]
    #[doc = ""]
    #[doc = "Any of the elements may be equal to 0, which means not to use `VkExportMemoryAllocateInfoKHR` on this memory type."]
    #[doc = "This is also the default in case of `pTypeExternalMemoryHandleTypes` = NULL."]
    pub pTypeExternalMemoryHandleTypes: *const VkExternalMemoryHandleTypeFlagsKHR,
}
impl Default for VmaAllocatorCreateInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Information about existing #VmaAllocator object."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VmaAllocatorInfo {
    #[doc = " \\brief Handle to Vulkan instance object."]
    #[doc = ""]
    #[doc = "This is the same value as has been passed through VmaAllocatorCreateInfo::instance."]
    pub instance: VkInstance,
    #[doc = " \\brief Handle to Vulkan physical device object."]
    #[doc = ""]
    #[doc = "This is the same value as has been passed through VmaAllocatorCreateInfo::physicalDevice."]
    pub physicalDevice: VkPhysicalDevice,
    #[doc = " \\brief Handle to Vulkan device object."]
    #[doc = ""]
    #[doc = "This is the same value as has been passed through VmaAllocatorCreateInfo::device."]
    pub device: VkDevice,
}
impl Default for VmaAllocatorInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief Calculated statistics of memory usage e.g. in a specific memory type, heap, custom pool, or total."]
#[doc = ""]
#[doc = "These are fast to calculate."]
#[doc = "See functions: vmaGetHeapBudgets(), vmaGetPoolStatistics()."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VmaStatistics {
    #[doc = " \\brief Number of `VkDeviceMemory` objects - Vulkan memory blocks allocated."]
    pub blockCount: u32,
    #[doc = " \\brief Number of #VmaAllocation objects allocated."]
    #[doc = ""]
    #[doc = "Dedicated allocations have their own blocks, so each one adds 1 to `allocationCount` as well as `blockCount`."]
    pub allocationCount: u32,
    #[doc = " \\brief Number of bytes allocated in `VkDeviceMemory` blocks."]
    #[doc = ""]
    #[doc = "\\note To avoid confusion, please be aware that what Vulkan calls an \"allocation\" - a whole `VkDeviceMemory` object"]
    #[doc = "(e.g. as in `VkPhysicalDeviceLimits::maxMemoryAllocationCount`) is called a \"block\" in VMA, while VMA calls"]
    #[doc = "\"allocation\" a #VmaAllocation object that represents a memory region sub-allocated from such block, usually for a single buffer or image."]
    pub blockBytes: VkDeviceSize,
    #[doc = " \\brief Total number of bytes occupied by all #VmaAllocation objects."]
    #[doc = ""]
    #[doc = "Always less or equal than `blockBytes`."]
    #[doc = "Difference `(blockBytes - allocationBytes)` is the amount of memory allocated from Vulkan"]
    #[doc = "but unused by any #VmaAllocation."]
    pub allocationBytes: VkDeviceSize,
}
#[doc = " \\brief More detailed statistics than #VmaStatistics."]
#[doc = ""]
#[doc = "These are slower to calculate. Use for debugging purposes."]
#[doc = "See functions: vmaCalculateStatistics(), vmaCalculatePoolStatistics()."]
#[doc = ""]
#[doc = "Previous version of the statistics API provided averages, but they have been removed"]
#[doc = "because they can be easily calculated as:"]
#[doc = ""]
#[doc = "\\code"]
#[doc = "VkDeviceSize allocationSizeAvg = detailedStats.statistics.allocationBytes / detailedStats.statistics.allocationCount;"]
#[doc = "VkDeviceSize unusedBytes = detailedStats.statistics.blockBytes - detailedStats.statistics.allocationBytes;"]
#[doc = "VkDeviceSize unusedRangeSizeAvg = unusedBytes / detailedStats.unusedRangeCount;"]
#[doc = "\\endcode"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VmaDetailedStatistics {
    #[doc = " Basic statistics."]
    pub statistics: VmaStatistics,
    #[doc = " Number of free ranges of memory between allocations."]
    pub unusedRangeCount: u32,
    #[doc = " Smallest allocation size. `VK_WHOLE_SIZE` if there are 0 allocations."]
    pub allocationSizeMin: VkDeviceSize,
    #[doc = " Largest allocation size. 0 if there are 0 allocations."]
    pub allocationSizeMax: VkDeviceSize,
    #[doc = " Smallest empty range size. `VK_WHOLE_SIZE` if there are 0 empty ranges."]
    pub unusedRangeSizeMin: VkDeviceSize,
    #[doc = " Largest empty range size. 0 if there are 0 empty ranges."]
    pub unusedRangeSizeMax: VkDeviceSize,
}
#[doc = " \\brief  General statistics from current state of the Allocator -"]
#[doc = "total memory usage across all memory heaps and types."]
#[doc = ""]
#[doc = "These are slower to calculate. Use for debugging purposes."]
#[doc = "See function vmaCalculateStatistics()."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VmaTotalStatistics {
    pub memoryType: [VmaDetailedStatistics; 32usize],
    pub memoryHeap: [VmaDetailedStatistics; 16usize],
    pub total: VmaDetailedStatistics,
}
#[doc = " \\brief Statistics of current memory usage and available budget for a specific memory heap."]
#[doc = ""]
#[doc = "These are fast to calculate."]
#[doc = "See function vmaGetHeapBudgets()."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VmaBudget {
    #[doc = " \\brief Statistics fetched from the library."]
    pub statistics: VmaStatistics,
    #[doc = " \\brief Estimated current memory usage of the program, in bytes."]
    #[doc = ""]
    #[doc = "Fetched from system using VK_EXT_memory_budget extension if enabled."]
    #[doc = ""]
    #[doc = "It might be different than `statistics.blockBytes` (usually higher) due to additional implicit objects"]
    #[doc = "also occupying the memory, like swapchain, pipelines, descriptor heaps, command buffers, or"]
    #[doc = "`VkDeviceMemory` blocks allocated outside of this library, if any."]
    pub usage: VkDeviceSize,
    #[doc = " \\brief Estimated amount of memory available to the program, in bytes."]
    #[doc = ""]
    #[doc = "Fetched from system using VK_EXT_memory_budget extension if enabled."]
    #[doc = ""]
    #[doc = "It might be different (most probably smaller) than `VkMemoryHeap::size[heapIndex]` due to factors"]
    #[doc = "external to the program, decided by the operating system."]
    #[doc = "Difference `budget - usage` is the amount of additional memory that can probably"]
    #[doc = "be allocated without problems. Exceeding the budget may result in various problems."]
    pub budget: VkDeviceSize,
}
#[doc = " \\brief Parameters of new #VmaAllocation."]
#[doc = ""]
#[doc = "To be used with functions like vmaCreateBuffer(), vmaCreateImage(), and many others."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VmaAllocationCreateInfo {
    #[doc = " Use #VmaAllocationCreateFlagBits enum."]
    pub flags: VmaAllocationCreateFlags,
    #[doc = " \\brief Intended usage of memory."]
    #[doc = ""]
    #[doc = "You can leave #VMA_MEMORY_USAGE_UNKNOWN if you specify memory requirements in other way. \\n"]
    #[doc = "If `pool` is not null, this member is ignored."]
    pub usage: VmaMemoryUsage,
    #[doc = " \\brief Flags that must be set in a Memory Type chosen for an allocation."]
    #[doc = ""]
    #[doc = "Leave 0 if you specify memory requirements in other way. \\n"]
    #[doc = "If `pool` is not null, this member is ignored."]
    pub requiredFlags: VkMemoryPropertyFlags,
    #[doc = " \\brief Flags that preferably should be set in a memory type chosen for an allocation."]
    #[doc = ""]
    #[doc = "Set to 0 if no additional flags are preferred. \\n"]
    #[doc = "If `pool` is not null, this member is ignored."]
    pub preferredFlags: VkMemoryPropertyFlags,
    #[doc = " \\brief Bitmask containing one bit set for every memory type acceptable for this allocation."]
    #[doc = ""]
    #[doc = "Value 0 is equivalent to `UINT32_MAX` - it means any memory type is accepted if"]
    #[doc = "it meets other requirements specified by this structure, with no further"]
    #[doc = "restrictions on memory type index. \\n"]
    #[doc = "If `pool` is not null, this member is ignored."]
    pub memoryTypeBits: u32,
    #[doc = " \\brief Pool that this allocation should be created in."]
    #[doc = ""]
    #[doc = "Leave `VK_NULL_HANDLE` to allocate from default pool. If not null, members:"]
    #[doc = "`usage`, `requiredFlags`, `preferredFlags`, `memoryTypeBits` are ignored."]
    pub pool: VmaPool,
    #[doc = " \\brief Custom general-purpose pointer that will be stored in #VmaAllocation, can be read as VmaAllocationInfo::pUserData and changed using vmaSetAllocationUserData()."]
    #[doc = ""]
    #[doc = "If #VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT is used, it must be either"]
    #[doc = "null or pointer to a null-terminated string. The string will be then copied to"]
    #[doc = "internal buffer, so it doesn't need to be valid after allocation call."]
    pub pUserData: *mut ::std::os::raw::c_void,
    #[doc = " \\brief A floating-point value between 0 and 1, indicating the priority of the allocation relative to other memory allocations."]
    #[doc = ""]
    #[doc = "It is used only when #VMA_ALLOCATOR_CREATE_EXT_MEMORY_PRIORITY_BIT flag was used during creation of the #VmaAllocator object"]
    #[doc = "and this allocation ends up as dedicated or is explicitly forced as dedicated using #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT."]
    #[doc = "Otherwise, it has the priority of a memory block where it is placed and this variable is ignored."]
    pub priority: f32,
}
impl Default for VmaAllocationCreateInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Describes parameter of created #VmaPool."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VmaPoolCreateInfo {
    #[doc = " \\brief Vulkan memory type index to allocate this pool from."]
    pub memoryTypeIndex: u32,
    #[doc = " \\brief Use combination of #VmaPoolCreateFlagBits."]
    pub flags: VmaPoolCreateFlags,
    #[doc = " \\brief Size of a single `VkDeviceMemory` block to be allocated as part of this pool, in bytes. Optional."]
    #[doc = ""]
    #[doc = "Specify nonzero to set explicit, constant size of memory blocks used by this"]
    #[doc = "pool."]
    #[doc = ""]
    #[doc = "Leave 0 to use default and let the library manage block sizes automatically."]
    #[doc = "Sizes of particular blocks may vary."]
    #[doc = "In this case, the pool will also support dedicated allocations."]
    pub blockSize: VkDeviceSize,
    #[doc = " \\brief Minimum number of blocks to be always allocated in this pool, even if they stay empty."]
    #[doc = ""]
    #[doc = "Set to 0 to have no preallocated blocks and allow the pool be completely empty."]
    pub minBlockCount: usize,
    #[doc = " \\brief Maximum number of blocks that can be allocated in this pool. Optional."]
    #[doc = ""]
    #[doc = "Set to 0 to use default, which is `SIZE_MAX`, which means no limit."]
    #[doc = ""]
    #[doc = "Set to same value as VmaPoolCreateInfo::minBlockCount to have fixed amount of memory allocated"]
    #[doc = "throughout whole lifetime of this pool."]
    pub maxBlockCount: usize,
    #[doc = " \\brief A floating-point value between 0 and 1, indicating the priority of the allocations in this pool relative to other memory allocations."]
    #[doc = ""]
    #[doc = "It is used only when #VMA_ALLOCATOR_CREATE_EXT_MEMORY_PRIORITY_BIT flag was used during creation of the #VmaAllocator object."]
    #[doc = "Otherwise, this variable is ignored."]
    pub priority: f32,
    #[doc = " \\brief Additional minimum alignment to be used for all allocations created from this pool. Can be 0."]
    #[doc = ""]
    #[doc = "Leave 0 (default) not to impose any additional alignment. If not 0, it must be a power of two."]
    #[doc = "It can be useful in cases where alignment returned by Vulkan by functions like `vkGetBufferMemoryRequirements` is not enough,"]
    #[doc = "e.g. when doing interop with OpenGL."]
    pub minAllocationAlignment: VkDeviceSize,
    #[doc = " \\brief Additional `pNext` chain to be attached to `VkMemoryAllocateInfo` used for every allocation made by this pool. Optional."]
    #[doc = ""]
    #[doc = "Optional, can be null. If not null, it must point to a `pNext` chain of structures that can be attached to `VkMemoryAllocateInfo`."]
    #[doc = "It can be useful for special needs such as adding `VkExportMemoryAllocateInfoKHR`."]
    #[doc = "Structures pointed by this member must remain alive and unchanged for the whole lifetime of the custom pool."]
    #[doc = ""]
    #[doc = "Please note that some structures, e.g. `VkMemoryPriorityAllocateInfoEXT`, `VkMemoryDedicatedAllocateInfoKHR`,"]
    #[doc = "can be attached automatically by this library when using other, more convenient of its features."]
    pub pMemoryAllocateNext: *mut ::std::os::raw::c_void,
}
impl Default for VmaPoolCreateInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Parameters of #VmaAllocation objects, that can be retrieved using function vmaGetAllocationInfo()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VmaAllocationInfo {
    #[doc = " \\brief Memory type index that this allocation was allocated from."]
    #[doc = ""]
    #[doc = "It never changes."]
    pub memoryType: u32,
    #[doc = " \\brief Handle to Vulkan memory object."]
    #[doc = ""]
    #[doc = "Same memory object can be shared by multiple allocations."]
    #[doc = ""]
    #[doc = "It can change after the allocation is moved during \\ref defragmentation."]
    pub deviceMemory: VkDeviceMemory,
    #[doc = " \\brief Offset in `VkDeviceMemory` object to the beginning of this allocation, in bytes. `(deviceMemory, offset)` pair is unique to this allocation."]
    #[doc = ""]
    #[doc = "You usually don't need to use this offset. If you create a buffer or an image together with the allocation using e.g. function"]
    #[doc = "vmaCreateBuffer(), vmaCreateImage(), functions that operate on these resources refer to the beginning of the buffer or image,"]
    #[doc = "not entire device memory block. Functions like vmaMapMemory(), vmaBindBufferMemory() also refer to the beginning of the allocation"]
    #[doc = "and apply this offset automatically."]
    #[doc = ""]
    #[doc = "It can change after the allocation is moved during \\ref defragmentation."]
    pub offset: VkDeviceSize,
    #[doc = " \\brief Size of this allocation, in bytes."]
    #[doc = ""]
    #[doc = "It never changes."]
    #[doc = ""]
    #[doc = "\\note Allocation size returned in this variable may be greater than the size"]
    #[doc = "requested for the resource e.g. as `VkBufferCreateInfo::size`. Whole size of the"]
    #[doc = "allocation is accessible for operations on memory e.g. using a pointer after"]
    #[doc = "mapping with vmaMapMemory(), but operations on the resource e.g. using"]
    #[doc = "`vkCmdCopyBuffer` must be limited to the size of the resource."]
    pub size: VkDeviceSize,
    #[doc = " \\brief Pointer to the beginning of this allocation as mapped data."]
    #[doc = ""]
    #[doc = "If the allocation hasn't been mapped using vmaMapMemory() and hasn't been"]
    #[doc = "created with #VMA_ALLOCATION_CREATE_MAPPED_BIT flag, this value is null."]
    #[doc = ""]
    #[doc = "It can change after call to vmaMapMemory(), vmaUnmapMemory()."]
    #[doc = "It can also change after the allocation is moved during \\ref defragmentation."]
    pub pMappedData: *mut ::std::os::raw::c_void,
    #[doc = " \\brief Custom general-purpose pointer that was passed as VmaAllocationCreateInfo::pUserData or set using vmaSetAllocationUserData()."]
    #[doc = ""]
    #[doc = "It can change after call to vmaSetAllocationUserData() for this allocation."]
    pub pUserData: *mut ::std::os::raw::c_void,
    #[doc = " \\brief Custom allocation name that was set with vmaSetAllocationName()."]
    #[doc = ""]
    #[doc = "It can change after call to vmaSetAllocationName() for this allocation."]
    #[doc = ""]
    #[doc = "Another way to set custom name is to pass it in VmaAllocationCreateInfo::pUserData with"]
    #[doc = "additional flag #VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT set [DEPRECATED]."]
    pub pName: *const ::std::os::raw::c_char,
}
impl Default for VmaAllocationInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief Parameters for defragmentation."]
#[doc = ""]
#[doc = "To be used with function vmaBeginDefragmentation()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VmaDefragmentationInfo {
    #[doc = " \\brief Use combination of #VmaDefragmentationFlagBits."]
    pub flags: VmaDefragmentationFlags,
    #[doc = " \\brief Custom pool to be defragmented."]
    #[doc = ""]
    #[doc = "If null then default pools will undergo defragmentation process."]
    pub pool: VmaPool,
    #[doc = " \\brief Maximum numbers of bytes that can be copied during single pass, while moving allocations to different places."]
    #[doc = ""]
    #[doc = "`0` means no limit."]
    pub maxBytesPerPass: VkDeviceSize,
    #[doc = " \\brief Maximum number of allocations that can be moved during single pass to a different place."]
    #[doc = ""]
    #[doc = "`0` means no limit."]
    pub maxAllocationsPerPass: u32,
}
impl Default for VmaDefragmentationInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Single move of an allocation to be done for defragmentation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VmaDefragmentationMove {
    #[doc = " Operation to be performed on the allocation by vmaEndDefragmentationPass(). Default value is #VMA_DEFRAGMENTATION_MOVE_OPERATION_COPY. You can modify it."]
    pub operation: VmaDefragmentationMoveOperation,
    #[doc = " Allocation that should be moved."]
    pub srcAllocation: VmaAllocation,
    #[doc = " \\brief Temporary allocation pointing to destination memory that will replace `srcAllocation`."]
    #[doc = ""]
    #[doc = "\\warning Do not store this allocation in your data structures! It exists only temporarily, for the duration of the defragmentation pass,"]
    #[doc = "to be used for binding new buffer/image to the destination memory using e.g. vmaBindBufferMemory()."]
    #[doc = "vmaEndDefragmentationPass() will destroy it and make `srcAllocation` point to this memory."]
    pub dstTmpAllocation: VmaAllocation,
}
impl Default for VmaDefragmentationMove {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief Parameters for incremental defragmentation steps."]
#[doc = ""]
#[doc = "To be used with function vmaBeginDefragmentationPass()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VmaDefragmentationPassMoveInfo {
    #[doc = " Number of elements in the `pMoves` array."]
    pub moveCount: u32,
    #[doc = " \\brief Array of moves to be performed by the user in the current defragmentation pass."]
    #[doc = ""]
    #[doc = "Pointer to an array of `moveCount` elements, owned by VMA, created in vmaBeginDefragmentationPass(), destroyed in vmaEndDefragmentationPass()."]
    #[doc = ""]
    #[doc = "For each element, you should:"]
    #[doc = ""]
    #[doc = "1. Create a new buffer/image in the place pointed by VmaDefragmentationMove::dstMemory + VmaDefragmentationMove::dstOffset."]
    #[doc = "2. Copy data from the VmaDefragmentationMove::srcAllocation e.g. using `vkCmdCopyBuffer`, `vkCmdCopyImage`."]
    #[doc = "3. Make sure these commands finished executing on the GPU."]
    #[doc = "4. Destroy the old buffer/image."]
    #[doc = ""]
    #[doc = "Only then you can finish defragmentation pass by calling vmaEndDefragmentationPass()."]
    #[doc = "After this call, the allocation will point to the new place in memory."]
    #[doc = ""]
    #[doc = "Alternatively, if you cannot move specific allocation, you can set VmaDefragmentationMove::operation to #VMA_DEFRAGMENTATION_MOVE_OPERATION_IGNORE."]
    #[doc = ""]
    #[doc = "Alternatively, if you decide you want to completely remove the allocation:"]
    #[doc = ""]
    #[doc = "1. Destroy its buffer/image."]
    #[doc = "2. Set VmaDefragmentationMove::operation to #VMA_DEFRAGMENTATION_MOVE_OPERATION_DESTROY."]
    #[doc = ""]
    #[doc = "Then, after vmaEndDefragmentationPass() the allocation will be freed."]
    pub pMoves: *mut VmaDefragmentationMove,
}
impl Default for VmaDefragmentationPassMoveInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Statistics returned for defragmentation process in function vmaEndDefragmentation()."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VmaDefragmentationStats {
    #[doc = " Total number of bytes that have been copied while moving allocations to different places."]
    pub bytesMoved: VkDeviceSize,
    #[doc = " Total number of bytes that have been released to the system by freeing empty `VkDeviceMemory` objects."]
    pub bytesFreed: VkDeviceSize,
    #[doc = " Number of allocations that have been moved to different places."]
    pub allocationsMoved: u32,
    #[doc = " Number of empty `VkDeviceMemory` objects that have been released to the system."]
    pub deviceMemoryBlocksFreed: u32,
}
#[doc = " Parameters of created #VmaVirtualBlock object to be passed to vmaCreateVirtualBlock()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VmaVirtualBlockCreateInfo {
    #[doc = " \\brief Total size of the virtual block."]
    #[doc = ""]
    #[doc = "Sizes can be expressed in bytes or any units you want as long as you are consistent in using them."]
    #[doc = "For example, if you allocate from some array of structures, 1 can mean single instance of entire structure."]
    pub size: VkDeviceSize,
    #[doc = " \\brief Use combination of #VmaVirtualBlockCreateFlagBits."]
    pub flags: VmaVirtualBlockCreateFlags,
    #[doc = " \\brief Custom CPU memory allocation callbacks. Optional."]
    #[doc = ""]
    #[doc = "Optional, can be null. When specified, they will be used for all CPU-side memory allocations."]
    pub pAllocationCallbacks: *const VkAllocationCallbacks,
}
impl Default for VmaVirtualBlockCreateInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Parameters of created virtual allocation to be passed to vmaVirtualAllocate()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VmaVirtualAllocationCreateInfo {
    #[doc = " \\brief Size of the allocation."]
    #[doc = ""]
    #[doc = "Cannot be zero."]
    pub size: VkDeviceSize,
    #[doc = " \\brief Required alignment of the allocation. Optional."]
    #[doc = ""]
    #[doc = "Must be power of two. Special value 0 has the same meaning as 1 - means no special alignment is required, so allocation can start at any offset."]
    pub alignment: VkDeviceSize,
    #[doc = " \\brief Use combination of #VmaVirtualAllocationCreateFlagBits."]
    pub flags: VmaVirtualAllocationCreateFlags,
    #[doc = " \\brief Custom pointer to be associated with the allocation. Optional."]
    #[doc = ""]
    #[doc = "It can be any value and can be used for user-defined purposes. It can be fetched or changed later."]
    pub pUserData: *mut ::std::os::raw::c_void,
}
impl Default for VmaVirtualAllocationCreateInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Parameters of an existing virtual allocation, returned by vmaGetVirtualAllocationInfo()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VmaVirtualAllocationInfo {
    #[doc = " \\brief Offset of the allocation."]
    #[doc = ""]
    #[doc = "Offset at which the allocation was made."]
    pub offset: VkDeviceSize,
    #[doc = " \\brief Size of the allocation."]
    #[doc = ""]
    #[doc = "Same value as passed in VmaVirtualAllocationCreateInfo::size."]
    pub size: VkDeviceSize,
    #[doc = " \\brief Custom pointer associated with the allocation."]
    #[doc = ""]
    #[doc = "Same value as passed in VmaVirtualAllocationCreateInfo::pUserData or to vmaSetVirtualAllocationUserData()."]
    pub pUserData: *mut ::std::os::raw::c_void,
}
impl Default for VmaVirtualAllocationInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " Creates #VmaAllocator object."]
    pub fn vmaCreateAllocator(
        pCreateInfo: *const VmaAllocatorCreateInfo,
        pAllocator: *mut VmaAllocator,
    ) -> VkResult;
}
extern "C" {
    #[doc = " Destroys allocator object."]
    pub fn vmaDestroyAllocator(allocator: VmaAllocator);
}
extern "C" {
    #[doc = " \\brief Returns information about existing #VmaAllocator object - handle to Vulkan device etc."]
    #[doc = ""]
    #[doc = "It might be useful if you want to keep just the #VmaAllocator handle and fetch other required handles to"]
    #[doc = "`VkPhysicalDevice`, `VkDevice` etc. every time using this function."]
    pub fn vmaGetAllocatorInfo(allocator: VmaAllocator, pAllocatorInfo: *mut VmaAllocatorInfo);
}
extern "C" {
    #[doc = "PhysicalDeviceProperties are fetched from physicalDevice by the allocator."]
    #[doc = "You can access it here, without fetching it again on your own."]
    pub fn vmaGetPhysicalDeviceProperties(
        allocator: VmaAllocator,
        ppPhysicalDeviceProperties: *mut *const VkPhysicalDeviceProperties,
    );
}
extern "C" {
    #[doc = "PhysicalDeviceMemoryProperties are fetched from physicalDevice by the allocator."]
    #[doc = "You can access it here, without fetching it again on your own."]
    pub fn vmaGetMemoryProperties(
        allocator: VmaAllocator,
        ppPhysicalDeviceMemoryProperties: *mut *const VkPhysicalDeviceMemoryProperties,
    );
}
extern "C" {
    #[doc = "\\brief Given Memory Type Index, returns Property Flags of this memory type."]
    #[doc = ""]
    #[doc = "This is just a convenience function. Same information can be obtained using"]
    #[doc = "vmaGetMemoryProperties()."]
    pub fn vmaGetMemoryTypeProperties(
        allocator: VmaAllocator,
        memoryTypeIndex: u32,
        pFlags: *mut VkMemoryPropertyFlags,
    );
}
extern "C" {
    #[doc = " \\brief Sets index of the current frame."]
    pub fn vmaSetCurrentFrameIndex(allocator: VmaAllocator, frameIndex: u32);
}
extern "C" {
    #[doc = " \\brief Retrieves statistics from current state of the Allocator."]
    #[doc = ""]
    #[doc = "This function is called \"calculate\" not \"get\" because it has to traverse all"]
    #[doc = "internal data structures, so it may be quite slow. Use it for debugging purposes."]
    #[doc = "For faster but more brief statistics suitable to be called every frame or every allocation,"]
    #[doc = "use vmaGetHeapBudgets()."]
    #[doc = ""]
    #[doc = "Note that when using allocator from multiple threads, returned information may immediately"]
    #[doc = "become outdated."]
    pub fn vmaCalculateStatistics(allocator: VmaAllocator, pStats: *mut VmaTotalStatistics);
}
extern "C" {
    #[doc = " \\brief Retrieves information about current memory usage and budget for all memory heaps."]
    #[doc = ""]
    #[doc = "\\param allocator"]
    #[doc = "\\param[out] pBudgets Must point to array with number of elements at least equal to number of memory heaps in physical device used."]
    #[doc = ""]
    #[doc = "This function is called \"get\" not \"calculate\" because it is very fast, suitable to be called"]
    #[doc = "every frame or every allocation. For more detailed statistics use vmaCalculateStatistics()."]
    #[doc = ""]
    #[doc = "Note that when using allocator from multiple threads, returned information may immediately"]
    #[doc = "become outdated."]
    pub fn vmaGetHeapBudgets(allocator: VmaAllocator, pBudgets: *mut VmaBudget);
}
extern "C" {
    #[doc = "\\brief Helps to find memoryTypeIndex, given memoryTypeBits and VmaAllocationCreateInfo."]
    #[doc = ""]
    #[doc = "This algorithm tries to find a memory type that:"]
    #[doc = ""]
    #[doc = "- Is allowed by memoryTypeBits."]
    #[doc = "- Contains all the flags from pAllocationCreateInfo->requiredFlags."]
    #[doc = "- Matches intended usage."]
    #[doc = "- Has as many flags from pAllocationCreateInfo->preferredFlags as possible."]
    #[doc = ""]
    #[doc = "\\return Returns VK_ERROR_FEATURE_NOT_PRESENT if not found. Receiving such result"]
    #[doc = "from this function or any other allocating function probably means that your"]
    #[doc = "device doesn't support any memory type with requested features for the specific"]
    #[doc = "type of resource you want to use it for. Please check parameters of your"]
    #[doc = "resource, like image layout (OPTIMAL versus LINEAR) or mip level count."]
    pub fn vmaFindMemoryTypeIndex(
        allocator: VmaAllocator,
        memoryTypeBits: u32,
        pAllocationCreateInfo: *const VmaAllocationCreateInfo,
        pMemoryTypeIndex: *mut u32,
    ) -> VkResult;
}
extern "C" {
    #[doc = "\\brief Helps to find memoryTypeIndex, given VkBufferCreateInfo and VmaAllocationCreateInfo."]
    #[doc = ""]
    #[doc = "It can be useful e.g. to determine value to be used as VmaPoolCreateInfo::memoryTypeIndex."]
    #[doc = "It internally creates a temporary, dummy buffer that never has memory bound."]
    pub fn vmaFindMemoryTypeIndexForBufferInfo(
        allocator: VmaAllocator,
        pBufferCreateInfo: *const VkBufferCreateInfo,
        pAllocationCreateInfo: *const VmaAllocationCreateInfo,
        pMemoryTypeIndex: *mut u32,
    ) -> VkResult;
}
extern "C" {
    #[doc = "\\brief Helps to find memoryTypeIndex, given VkImageCreateInfo and VmaAllocationCreateInfo."]
    #[doc = ""]
    #[doc = "It can be useful e.g. to determine value to be used as VmaPoolCreateInfo::memoryTypeIndex."]
    #[doc = "It internally creates a temporary, dummy image that never has memory bound."]
    pub fn vmaFindMemoryTypeIndexForImageInfo(
        allocator: VmaAllocator,
        pImageCreateInfo: *const VkImageCreateInfo,
        pAllocationCreateInfo: *const VmaAllocationCreateInfo,
        pMemoryTypeIndex: *mut u32,
    ) -> VkResult;
}
extern "C" {
    #[doc = " \\brief Allocates Vulkan device memory and creates #VmaPool object."]
    #[doc = ""]
    #[doc = "\\param allocator Allocator object."]
    #[doc = "\\param pCreateInfo Parameters of pool to create."]
    #[doc = "\\param[out] pPool Handle to created pool."]
    pub fn vmaCreatePool(
        allocator: VmaAllocator,
        pCreateInfo: *const VmaPoolCreateInfo,
        pPool: *mut VmaPool,
    ) -> VkResult;
}
extern "C" {
    #[doc = " \\brief Destroys #VmaPool object and frees Vulkan device memory."]
    pub fn vmaDestroyPool(allocator: VmaAllocator, pool: VmaPool);
}
extern "C" {
    #[doc = " \\brief Retrieves statistics of existing #VmaPool object."]
    #[doc = ""]
    #[doc = "\\param allocator Allocator object."]
    #[doc = "\\param pool Pool object."]
    #[doc = "\\param[out] pPoolStats Statistics of specified pool."]
    pub fn vmaGetPoolStatistics(
        allocator: VmaAllocator,
        pool: VmaPool,
        pPoolStats: *mut VmaStatistics,
    );
}
extern "C" {
    #[doc = " \\brief Retrieves detailed statistics of existing #VmaPool object."]
    #[doc = ""]
    #[doc = "\\param allocator Allocator object."]
    #[doc = "\\param pool Pool object."]
    #[doc = "\\param[out] pPoolStats Statistics of specified pool."]
    pub fn vmaCalculatePoolStatistics(
        allocator: VmaAllocator,
        pool: VmaPool,
        pPoolStats: *mut VmaDetailedStatistics,
    );
}
extern "C" {
    #[doc = " \\brief Checks magic number in margins around all allocations in given memory pool in search for corruptions."]
    #[doc = ""]
    #[doc = "Corruption detection is enabled only when `VMA_DEBUG_DETECT_CORRUPTION` macro is defined to nonzero,"]
    #[doc = "`VMA_DEBUG_MARGIN` is defined to nonzero and the pool is created in memory type that is"]
    #[doc = "`HOST_VISIBLE` and `HOST_COHERENT`. For more information, see [Corruption detection](@ref debugging_memory_usage_corruption_detection)."]
    #[doc = ""]
    #[doc = "Possible return values:"]
    #[doc = ""]
    #[doc = "- `VK_ERROR_FEATURE_NOT_PRESENT` - corruption detection is not enabled for specified pool."]
    #[doc = "- `VK_SUCCESS` - corruption detection has been performed and succeeded."]
    #[doc = "- `VK_ERROR_UNKNOWN` - corruption detection has been performed and found memory corruptions around one of the allocations."]
    #[doc = "`VMA_ASSERT` is also fired in that case."]
    #[doc = "- Other value: Error returned by Vulkan, e.g. memory mapping failure."]
    pub fn vmaCheckPoolCorruption(allocator: VmaAllocator, pool: VmaPool) -> VkResult;
}
extern "C" {
    #[doc = " \\brief Retrieves name of a custom pool."]
    #[doc = ""]
    #[doc = "After the call `ppName` is either null or points to an internally-owned null-terminated string"]
    #[doc = "containing name of the pool that was previously set. The pointer becomes invalid when the pool is"]
    #[doc = "destroyed or its name is changed using vmaSetPoolName()."]
    pub fn vmaGetPoolName(
        allocator: VmaAllocator,
        pool: VmaPool,
        ppName: *mut *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " \\brief Sets name of a custom pool."]
    #[doc = ""]
    #[doc = "`pName` can be either null or pointer to a null-terminated string with new name for the pool."]
    #[doc = "Function makes internal copy of the string, so it can be changed or freed immediately after this call."]
    pub fn vmaSetPoolName(
        allocator: VmaAllocator,
        pool: VmaPool,
        pName: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " \\brief General purpose memory allocation."]
    #[doc = ""]
    #[doc = "\\param allocator"]
    #[doc = "\\param pVkMemoryRequirements"]
    #[doc = "\\param pCreateInfo"]
    #[doc = "\\param[out] pAllocation Handle to allocated memory."]
    #[doc = "\\param[out] pAllocationInfo Optional. Information about allocated memory. It can be later fetched using function vmaGetAllocationInfo()."]
    #[doc = ""]
    #[doc = "You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages()."]
    #[doc = ""]
    #[doc = "It is recommended to use vmaAllocateMemoryForBuffer(), vmaAllocateMemoryForImage(),"]
    #[doc = "vmaCreateBuffer(), vmaCreateImage() instead whenever possible."]
    pub fn vmaAllocateMemory(
        allocator: VmaAllocator,
        pVkMemoryRequirements: *const VkMemoryRequirements,
        pCreateInfo: *const VmaAllocationCreateInfo,
        pAllocation: *mut VmaAllocation,
        pAllocationInfo: *mut VmaAllocationInfo,
    ) -> VkResult;
}
extern "C" {
    #[doc = " \\brief General purpose memory allocation for multiple allocation objects at once."]
    #[doc = ""]
    #[doc = "\\param allocator Allocator object."]
    #[doc = "\\param pVkMemoryRequirements Memory requirements for each allocation."]
    #[doc = "\\param pCreateInfo Creation parameters for each allocation."]
    #[doc = "\\param allocationCount Number of allocations to make."]
    #[doc = "\\param[out] pAllocations Pointer to array that will be filled with handles to created allocations."]
    #[doc = "\\param[out] pAllocationInfo Optional. Pointer to array that will be filled with parameters of created allocations."]
    #[doc = ""]
    #[doc = "You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages()."]
    #[doc = ""]
    #[doc = "Word \"pages\" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding."]
    #[doc = "It is just a general purpose allocation function able to make multiple allocations at once."]
    #[doc = "It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times."]
    #[doc = ""]
    #[doc = "All allocations are made using same parameters. All of them are created out of the same memory pool and type."]
    #[doc = "If any allocation fails, all allocations already made within this function call are also freed, so that when"]
    #[doc = "returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`."]
    pub fn vmaAllocateMemoryPages(
        allocator: VmaAllocator,
        pVkMemoryRequirements: *const VkMemoryRequirements,
        pCreateInfo: *const VmaAllocationCreateInfo,
        allocationCount: usize,
        pAllocations: *mut VmaAllocation,
        pAllocationInfo: *mut VmaAllocationInfo,
    ) -> VkResult;
}
extern "C" {
    #[doc = " \\brief Allocates memory suitable for given `VkBuffer`."]
    #[doc = ""]
    #[doc = "\\param allocator"]
    #[doc = "\\param buffer"]
    #[doc = "\\param pCreateInfo"]
    #[doc = "\\param[out] pAllocation Handle to allocated memory."]
    #[doc = "\\param[out] pAllocationInfo Optional. Information about allocated memory. It can be later fetched using function vmaGetAllocationInfo()."]
    #[doc = ""]
    #[doc = "It only creates #VmaAllocation. To bind the memory to the buffer, use vmaBindBufferMemory()."]
    #[doc = ""]
    #[doc = "This is a special-purpose function. In most cases you should use vmaCreateBuffer()."]
    #[doc = ""]
    #[doc = "You must free the allocation using vmaFreeMemory() when no longer needed."]
    pub fn vmaAllocateMemoryForBuffer(
        allocator: VmaAllocator,
        buffer: VkBuffer,
        pCreateInfo: *const VmaAllocationCreateInfo,
        pAllocation: *mut VmaAllocation,
        pAllocationInfo: *mut VmaAllocationInfo,
    ) -> VkResult;
}
extern "C" {
    #[doc = " \\brief Allocates memory suitable for given `VkImage`."]
    #[doc = ""]
    #[doc = "\\param allocator"]
    #[doc = "\\param image"]
    #[doc = "\\param pCreateInfo"]
    #[doc = "\\param[out] pAllocation Handle to allocated memory."]
    #[doc = "\\param[out] pAllocationInfo Optional. Information about allocated memory. It can be later fetched using function vmaGetAllocationInfo()."]
    #[doc = ""]
    #[doc = "It only creates #VmaAllocation. To bind the memory to the buffer, use vmaBindImageMemory()."]
    #[doc = ""]
    #[doc = "This is a special-purpose function. In most cases you should use vmaCreateImage()."]
    #[doc = ""]
    #[doc = "You must free the allocation using vmaFreeMemory() when no longer needed."]
    pub fn vmaAllocateMemoryForImage(
        allocator: VmaAllocator,
        image: VkImage,
        pCreateInfo: *const VmaAllocationCreateInfo,
        pAllocation: *mut VmaAllocation,
        pAllocationInfo: *mut VmaAllocationInfo,
    ) -> VkResult;
}
extern "C" {
    #[doc = " \\brief Frees memory previously allocated using vmaAllocateMemory(), vmaAllocateMemoryForBuffer(), or vmaAllocateMemoryForImage()."]
    #[doc = ""]
    #[doc = "Passing `VK_NULL_HANDLE` as `allocation` is valid. Such function call is just skipped."]
    pub fn vmaFreeMemory(allocator: VmaAllocator, allocation: VmaAllocation);
}
extern "C" {
    #[doc = " \\brief Frees memory and destroys multiple allocations."]
    #[doc = ""]
    #[doc = "Word \"pages\" is just a suggestion to use this function to free pieces of memory used for sparse binding."]
    #[doc = "It is just a general purpose function to free memory and destroy allocations made using e.g. vmaAllocateMemory(),"]
    #[doc = "vmaAllocateMemoryPages() and other functions."]
    #[doc = "It may be internally optimized to be more efficient than calling vmaFreeMemory() `allocationCount` times."]
    #[doc = ""]
    #[doc = "Allocations in `pAllocations` array can come from any memory pools and types."]
    #[doc = "Passing `VK_NULL_HANDLE` as elements of `pAllocations` array is valid. Such entries are just skipped."]
    pub fn vmaFreeMemoryPages(
        allocator: VmaAllocator,
        allocationCount: usize,
        pAllocations: *const *mut VmaAllocation_T,
    );
}
extern "C" {
    #[doc = " \\brief Returns current information about specified allocation."]
    #[doc = ""]
    #[doc = "Current paramteres of given allocation are returned in `pAllocationInfo`."]
    #[doc = ""]
    #[doc = "Although this function doesn't lock any mutex, so it should be quite efficient,"]
    #[doc = "you should avoid calling it too often."]
    #[doc = "You can retrieve same VmaAllocationInfo structure while creating your resource, from function"]
    #[doc = "vmaCreateBuffer(), vmaCreateImage(). You can remember it if you are sure parameters don't change"]
    #[doc = "(e.g. due to defragmentation)."]
    pub fn vmaGetAllocationInfo(
        allocator: VmaAllocator,
        allocation: VmaAllocation,
        pAllocationInfo: *mut VmaAllocationInfo,
    );
}
extern "C" {
    #[doc = " \\brief Sets pUserData in given allocation to new value."]
    #[doc = ""]
    #[doc = "The value of pointer `pUserData` is copied to allocation's `pUserData`."]
    #[doc = "It is opaque, so you can use it however you want - e.g."]
    #[doc = "as a pointer, ordinal number or some handle to you own data."]
    pub fn vmaSetAllocationUserData(
        allocator: VmaAllocator,
        allocation: VmaAllocation,
        pUserData: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " \\brief Sets pName in given allocation to new value."]
    #[doc = ""]
    #[doc = "`pName` must be either null, or pointer to a null-terminated string. The function"]
    #[doc = "makes local copy of the string and sets it as allocation's `pName`. String"]
    #[doc = "passed as pName doesn't need to be valid for whole lifetime of the allocation -"]
    #[doc = "you can free it after this call. String previously pointed by allocation's"]
    #[doc = "`pName` is freed from memory."]
    pub fn vmaSetAllocationName(
        allocator: VmaAllocator,
        allocation: VmaAllocation,
        pName: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = "\\brief Given an allocation, returns Property Flags of its memory type."]
    #[doc = ""]
    #[doc = "This is just a convenience function. Same information can be obtained using"]
    #[doc = "vmaGetAllocationInfo() + vmaGetMemoryProperties()."]
    pub fn vmaGetAllocationMemoryProperties(
        allocator: VmaAllocator,
        allocation: VmaAllocation,
        pFlags: *mut VkMemoryPropertyFlags,
    );
}
extern "C" {
    #[doc = " \\brief Maps memory represented by given allocation and returns pointer to it."]
    #[doc = ""]
    #[doc = "Maps memory represented by given allocation to make it accessible to CPU code."]
    #[doc = "When succeeded, `*ppData` contains pointer to first byte of this memory."]
    #[doc = ""]
    #[doc = "\\warning"]
    #[doc = "If the allocation is part of a bigger `VkDeviceMemory` block, returned pointer is"]
    #[doc = "correctly offsetted to the beginning of region assigned to this particular allocation."]
    #[doc = "Unlike the result of `vkMapMemory`, it points to the allocation, not to the beginning of the whole block."]
    #[doc = "You should not add VmaAllocationInfo::offset to it!"]
    #[doc = ""]
    #[doc = "Mapping is internally reference-counted and synchronized, so despite raw Vulkan"]
    #[doc = "function `vkMapMemory()` cannot be used to map same block of `VkDeviceMemory`"]
    #[doc = "multiple times simultaneously, it is safe to call this function on allocations"]
    #[doc = "assigned to the same memory block. Actual Vulkan memory will be mapped on first"]
    #[doc = "mapping and unmapped on last unmapping."]
    #[doc = ""]
    #[doc = "If the function succeeded, you must call vmaUnmapMemory() to unmap the"]
    #[doc = "allocation when mapping is no longer needed or before freeing the allocation, at"]
    #[doc = "the latest."]
    #[doc = ""]
    #[doc = "It also safe to call this function multiple times on the same allocation. You"]
    #[doc = "must call vmaUnmapMemory() same number of times as you called vmaMapMemory()."]
    #[doc = ""]
    #[doc = "It is also safe to call this function on allocation created with"]
    #[doc = "#VMA_ALLOCATION_CREATE_MAPPED_BIT flag. Its memory stays mapped all the time."]
    #[doc = "You must still call vmaUnmapMemory() same number of times as you called"]
    #[doc = "vmaMapMemory(). You must not call vmaUnmapMemory() additional time to free the"]
    #[doc = "\"0-th\" mapping made automatically due to #VMA_ALLOCATION_CREATE_MAPPED_BIT flag."]
    #[doc = ""]
    #[doc = "This function fails when used on allocation made in memory type that is not"]
    #[doc = "`HOST_VISIBLE`."]
    #[doc = ""]
    #[doc = "This function doesn't automatically flush or invalidate caches."]
    #[doc = "If the allocation is made from a memory types that is not `HOST_COHERENT`,"]
    #[doc = "you also need to use vmaInvalidateAllocation() / vmaFlushAllocation(), as required by Vulkan specification."]
    pub fn vmaMapMemory(
        allocator: VmaAllocator,
        allocation: VmaAllocation,
        ppData: *mut *mut ::std::os::raw::c_void,
    ) -> VkResult;
}
extern "C" {
    #[doc = " \\brief Unmaps memory represented by given allocation, mapped previously using vmaMapMemory()."]
    #[doc = ""]
    #[doc = "For details, see description of vmaMapMemory()."]
    #[doc = ""]
    #[doc = "This function doesn't automatically flush or invalidate caches."]
    #[doc = "If the allocation is made from a memory types that is not `HOST_COHERENT`,"]
    #[doc = "you also need to use vmaInvalidateAllocation() / vmaFlushAllocation(), as required by Vulkan specification."]
    pub fn vmaUnmapMemory(allocator: VmaAllocator, allocation: VmaAllocation);
}
extern "C" {
    #[doc = " \\brief Flushes memory of given allocation."]
    #[doc = ""]
    #[doc = "Calls `vkFlushMappedMemoryRanges()` for memory associated with given range of given allocation."]
    #[doc = "It needs to be called after writing to a mapped memory for memory types that are not `HOST_COHERENT`."]
    #[doc = "Unmap operation doesn't do that automatically."]
    #[doc = ""]
    #[doc = "- `offset` must be relative to the beginning of allocation."]
    #[doc = "- `size` can be `VK_WHOLE_SIZE`. It means all memory from `offset` the the end of given allocation."]
    #[doc = "- `offset` and `size` don't have to be aligned."]
    #[doc = "They are internally rounded down/up to multiply of `nonCoherentAtomSize`."]
    #[doc = "- If `size` is 0, this call is ignored."]
    #[doc = "- If memory type that the `allocation` belongs to is not `HOST_VISIBLE` or it is `HOST_COHERENT`,"]
    #[doc = "this call is ignored."]
    #[doc = ""]
    #[doc = "Warning! `offset` and `size` are relative to the contents of given `allocation`."]
    #[doc = "If you mean whole allocation, you can pass 0 and `VK_WHOLE_SIZE`, respectively."]
    #[doc = "Do not pass allocation's offset as `offset`!!!"]
    #[doc = ""]
    #[doc = "This function returns the `VkResult` from `vkFlushMappedMemoryRanges` if it is"]
    #[doc = "called, otherwise `VK_SUCCESS`."]
    pub fn vmaFlushAllocation(
        allocator: VmaAllocator,
        allocation: VmaAllocation,
        offset: VkDeviceSize,
        size: VkDeviceSize,
    ) -> VkResult;
}
extern "C" {
    #[doc = " \\brief Invalidates memory of given allocation."]
    #[doc = ""]
    #[doc = "Calls `vkInvalidateMappedMemoryRanges()` for memory associated with given range of given allocation."]
    #[doc = "It needs to be called before reading from a mapped memory for memory types that are not `HOST_COHERENT`."]
    #[doc = "Map operation doesn't do that automatically."]
    #[doc = ""]
    #[doc = "- `offset` must be relative to the beginning of allocation."]
    #[doc = "- `size` can be `VK_WHOLE_SIZE`. It means all memory from `offset` the the end of given allocation."]
    #[doc = "- `offset` and `size` don't have to be aligned."]
    #[doc = "They are internally rounded down/up to multiply of `nonCoherentAtomSize`."]
    #[doc = "- If `size` is 0, this call is ignored."]
    #[doc = "- If memory type that the `allocation` belongs to is not `HOST_VISIBLE` or it is `HOST_COHERENT`,"]
    #[doc = "this call is ignored."]
    #[doc = ""]
    #[doc = "Warning! `offset` and `size` are relative to the contents of given `allocation`."]
    #[doc = "If you mean whole allocation, you can pass 0 and `VK_WHOLE_SIZE`, respectively."]
    #[doc = "Do not pass allocation's offset as `offset`!!!"]
    #[doc = ""]
    #[doc = "This function returns the `VkResult` from `vkInvalidateMappedMemoryRanges` if"]
    #[doc = "it is called, otherwise `VK_SUCCESS`."]
    pub fn vmaInvalidateAllocation(
        allocator: VmaAllocator,
        allocation: VmaAllocation,
        offset: VkDeviceSize,
        size: VkDeviceSize,
    ) -> VkResult;
}
extern "C" {
    #[doc = " \\brief Flushes memory of given set of allocations."]
    #[doc = ""]
    #[doc = "Calls `vkFlushMappedMemoryRanges()` for memory associated with given ranges of given allocations."]
    #[doc = "For more information, see documentation of vmaFlushAllocation()."]
    #[doc = ""]
    #[doc = "\\param allocator"]
    #[doc = "\\param allocationCount"]
    #[doc = "\\param allocations"]
    #[doc = "\\param offsets If not null, it must point to an array of offsets of regions to flush, relative to the beginning of respective allocations. Null means all ofsets are zero."]
    #[doc = "\\param sizes If not null, it must point to an array of sizes of regions to flush in respective allocations. Null means `VK_WHOLE_SIZE` for all allocations."]
    #[doc = ""]
    #[doc = "This function returns the `VkResult` from `vkFlushMappedMemoryRanges` if it is"]
    #[doc = "called, otherwise `VK_SUCCESS`."]
    pub fn vmaFlushAllocations(
        allocator: VmaAllocator,
        allocationCount: u32,
        allocations: *const *mut VmaAllocation_T,
        offsets: *const VkDeviceSize,
        sizes: *const VkDeviceSize,
    ) -> VkResult;
}
extern "C" {
    #[doc = " \\brief Invalidates memory of given set of allocations."]
    #[doc = ""]
    #[doc = "Calls `vkInvalidateMappedMemoryRanges()` for memory associated with given ranges of given allocations."]
    #[doc = "For more information, see documentation of vmaInvalidateAllocation()."]
    #[doc = ""]
    #[doc = "\\param allocator"]
    #[doc = "\\param allocationCount"]
    #[doc = "\\param allocations"]
    #[doc = "\\param offsets If not null, it must point to an array of offsets of regions to flush, relative to the beginning of respective allocations. Null means all ofsets are zero."]
    #[doc = "\\param sizes If not null, it must point to an array of sizes of regions to flush in respective allocations. Null means `VK_WHOLE_SIZE` for all allocations."]
    #[doc = ""]
    #[doc = "This function returns the `VkResult` from `vkInvalidateMappedMemoryRanges` if it is"]
    #[doc = "called, otherwise `VK_SUCCESS`."]
    pub fn vmaInvalidateAllocations(
        allocator: VmaAllocator,
        allocationCount: u32,
        allocations: *const *mut VmaAllocation_T,
        offsets: *const VkDeviceSize,
        sizes: *const VkDeviceSize,
    ) -> VkResult;
}
extern "C" {
    #[doc = " \\brief Checks magic number in margins around all allocations in given memory types (in both default and custom pools) in search for corruptions."]
    #[doc = ""]
    #[doc = "\\param allocator"]
    #[doc = "\\param memoryTypeBits Bit mask, where each bit set means that a memory type with that index should be checked."]
    #[doc = ""]
    #[doc = "Corruption detection is enabled only when `VMA_DEBUG_DETECT_CORRUPTION` macro is defined to nonzero,"]
    #[doc = "`VMA_DEBUG_MARGIN` is defined to nonzero and only for memory types that are"]
    #[doc = "`HOST_VISIBLE` and `HOST_COHERENT`. For more information, see [Corruption detection](@ref debugging_memory_usage_corruption_detection)."]
    #[doc = ""]
    #[doc = "Possible return values:"]
    #[doc = ""]
    #[doc = "- `VK_ERROR_FEATURE_NOT_PRESENT` - corruption detection is not enabled for any of specified memory types."]
    #[doc = "- `VK_SUCCESS` - corruption detection has been performed and succeeded."]
    #[doc = "- `VK_ERROR_UNKNOWN` - corruption detection has been performed and found memory corruptions around one of the allocations."]
    #[doc = "`VMA_ASSERT` is also fired in that case."]
    #[doc = "- Other value: Error returned by Vulkan, e.g. memory mapping failure."]
    pub fn vmaCheckCorruption(allocator: VmaAllocator, memoryTypeBits: u32) -> VkResult;
}
extern "C" {
    #[doc = " \\brief Begins defragmentation process."]
    #[doc = ""]
    #[doc = "\\param allocator Allocator object."]
    #[doc = "\\param pInfo Structure filled with parameters of defragmentation."]
    #[doc = "\\param[out] pContext Context object that must be passed to vmaEndDefragmentation() to finish defragmentation."]
    #[doc = "\\returns"]
    #[doc = "- `VK_SUCCESS` if defragmentation can begin."]
    #[doc = "- `VK_ERROR_FEATURE_NOT_PRESENT` if defragmentation is not supported."]
    #[doc = ""]
    #[doc = "For more information about defragmentation, see documentation chapter:"]
    #[doc = "[Defragmentation](@ref defragmentation)."]
    pub fn vmaBeginDefragmentation(
        allocator: VmaAllocator,
        pInfo: *const VmaDefragmentationInfo,
        pContext: *mut VmaDefragmentationContext,
    ) -> VkResult;
}
extern "C" {
    #[doc = " \\brief Ends defragmentation process."]
    #[doc = ""]
    #[doc = "\\param allocator Allocator object."]
    #[doc = "\\param context Context object that has been created by vmaBeginDefragmentation()."]
    #[doc = "\\param[out] pStats Optional stats for the defragmentation. Can be null."]
    #[doc = ""]
    #[doc = "Use this function to finish defragmentation started by vmaBeginDefragmentation()."]
    pub fn vmaEndDefragmentation(
        allocator: VmaAllocator,
        context: VmaDefragmentationContext,
        pStats: *mut VmaDefragmentationStats,
    );
}
extern "C" {
    #[doc = " \\brief Starts single defragmentation pass."]
    #[doc = ""]
    #[doc = "\\param allocator Allocator object."]
    #[doc = "\\param context Context object that has been created by vmaBeginDefragmentation()."]
    #[doc = "\\param[out] pPassInfo Computed informations for current pass."]
    #[doc = "\\returns"]
    #[doc = "- `VK_SUCCESS` if no more moves are possible. Then you can omit call to vmaEndDefragmentationPass() and simply end whole defragmentation."]
    #[doc = "- `VK_INCOMPLETE` if there are pending moves returned in `pPassInfo`. You need to perform them, call vmaEndDefragmentationPass(),"]
    #[doc = "and then preferably try another pass with vmaBeginDefragmentationPass()."]
    pub fn vmaBeginDefragmentationPass(
        allocator: VmaAllocator,
        context: VmaDefragmentationContext,
        pPassInfo: *mut VmaDefragmentationPassMoveInfo,
    ) -> VkResult;
}
extern "C" {
    #[doc = " \\brief Ends single defragmentation pass."]
    #[doc = ""]
    #[doc = "\\param allocator Allocator object."]
    #[doc = "\\param context Context object that has been created by vmaBeginDefragmentation()."]
    #[doc = "\\param pPassInfo Computed informations for current pass filled by vmaBeginDefragmentationPass() and possibly modified by you."]
    #[doc = ""]
    #[doc = "Returns `VK_SUCCESS` if no more moves are possible or `VK_INCOMPLETE` if more defragmentations are possible."]
    #[doc = ""]
    #[doc = "Ends incremental defragmentation pass and commits all defragmentation moves from `pPassInfo`."]
    #[doc = "After this call:"]
    #[doc = ""]
    #[doc = "- Allocations at `pPassInfo[i].srcAllocation` that had `pPassInfo[i].operation ==` #VMA_DEFRAGMENTATION_MOVE_OPERATION_COPY"]
    #[doc = "(which is the default) will be pointing to the new destination place."]
    #[doc = "- Allocation at `pPassInfo[i].srcAllocation` that had `pPassInfo[i].operation ==` #VMA_DEFRAGMENTATION_MOVE_OPERATION_DESTROY"]
    #[doc = "will be freed."]
    #[doc = ""]
    #[doc = "If no more moves are possible you can end whole defragmentation."]
    pub fn vmaEndDefragmentationPass(
        allocator: VmaAllocator,
        context: VmaDefragmentationContext,
        pPassInfo: *mut VmaDefragmentationPassMoveInfo,
    ) -> VkResult;
}
extern "C" {
    #[doc = " \\brief Binds buffer to allocation."]
    #[doc = ""]
    #[doc = "Binds specified buffer to region of memory represented by specified allocation."]
    #[doc = "Gets `VkDeviceMemory` handle and offset from the allocation."]
    #[doc = "If you want to create a buffer, allocate memory for it and bind them together separately,"]
    #[doc = "you should use this function for binding instead of standard `vkBindBufferMemory()`,"]
    #[doc = "because it ensures proper synchronization so that when a `VkDeviceMemory` object is used by multiple"]
    #[doc = "allocations, calls to `vkBind*Memory()` or `vkMapMemory()` won't happen from multiple threads simultaneously"]
    #[doc = "(which is illegal in Vulkan)."]
    #[doc = ""]
    #[doc = "It is recommended to use function vmaCreateBuffer() instead of this one."]
    pub fn vmaBindBufferMemory(
        allocator: VmaAllocator,
        allocation: VmaAllocation,
        buffer: VkBuffer,
    ) -> VkResult;
}
extern "C" {
    #[doc = " \\brief Binds buffer to allocation with additional parameters."]
    #[doc = ""]
    #[doc = "\\param allocator"]
    #[doc = "\\param allocation"]
    #[doc = "\\param allocationLocalOffset Additional offset to be added while binding, relative to the beginning of the `allocation`. Normally it should be 0."]
    #[doc = "\\param buffer"]
    #[doc = "\\param pNext A chain of structures to be attached to `VkBindBufferMemoryInfoKHR` structure used internally. Normally it should be null."]
    #[doc = ""]
    #[doc = "This function is similar to vmaBindBufferMemory(), but it provides additional parameters."]
    #[doc = ""]
    #[doc = "If `pNext` is not null, #VmaAllocator object must have been created with #VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT flag"]
    #[doc = "or with VmaAllocatorCreateInfo::vulkanApiVersion `>= VK_API_VERSION_1_1`. Otherwise the call fails."]
    pub fn vmaBindBufferMemory2(
        allocator: VmaAllocator,
        allocation: VmaAllocation,
        allocationLocalOffset: VkDeviceSize,
        buffer: VkBuffer,
        pNext: *const ::std::os::raw::c_void,
    ) -> VkResult;
}
extern "C" {
    #[doc = " \\brief Binds image to allocation."]
    #[doc = ""]
    #[doc = "Binds specified image to region of memory represented by specified allocation."]
    #[doc = "Gets `VkDeviceMemory` handle and offset from the allocation."]
    #[doc = "If you want to create an image, allocate memory for it and bind them together separately,"]
    #[doc = "you should use this function for binding instead of standard `vkBindImageMemory()`,"]
    #[doc = "because it ensures proper synchronization so that when a `VkDeviceMemory` object is used by multiple"]
    #[doc = "allocations, calls to `vkBind*Memory()` or `vkMapMemory()` won't happen from multiple threads simultaneously"]
    #[doc = "(which is illegal in Vulkan)."]
    #[doc = ""]
    #[doc = "It is recommended to use function vmaCreateImage() instead of this one."]
    pub fn vmaBindImageMemory(
        allocator: VmaAllocator,
        allocation: VmaAllocation,
        image: VkImage,
    ) -> VkResult;
}
extern "C" {
    #[doc = " \\brief Binds image to allocation with additional parameters."]
    #[doc = ""]
    #[doc = "\\param allocator"]
    #[doc = "\\param allocation"]
    #[doc = "\\param allocationLocalOffset Additional offset to be added while binding, relative to the beginning of the `allocation`. Normally it should be 0."]
    #[doc = "\\param image"]
    #[doc = "\\param pNext A chain of structures to be attached to `VkBindImageMemoryInfoKHR` structure used internally. Normally it should be null."]
    #[doc = ""]
    #[doc = "This function is similar to vmaBindImageMemory(), but it provides additional parameters."]
    #[doc = ""]
    #[doc = "If `pNext` is not null, #VmaAllocator object must have been created with #VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT flag"]
    #[doc = "or with VmaAllocatorCreateInfo::vulkanApiVersion `>= VK_API_VERSION_1_1`. Otherwise the call fails."]
    pub fn vmaBindImageMemory2(
        allocator: VmaAllocator,
        allocation: VmaAllocation,
        allocationLocalOffset: VkDeviceSize,
        image: VkImage,
        pNext: *const ::std::os::raw::c_void,
    ) -> VkResult;
}
extern "C" {
    #[doc = " \\brief Creates a new `VkBuffer`, allocates and binds memory for it."]
    #[doc = ""]
    #[doc = "\\param allocator"]
    #[doc = "\\param pBufferCreateInfo"]
    #[doc = "\\param pAllocationCreateInfo"]
    #[doc = "\\param[out] pBuffer Buffer that was created."]
    #[doc = "\\param[out] pAllocation Allocation that was created."]
    #[doc = "\\param[out] pAllocationInfo Optional. Information about allocated memory. It can be later fetched using function vmaGetAllocationInfo()."]
    #[doc = ""]
    #[doc = "This function automatically:"]
    #[doc = ""]
    #[doc = "-# Creates buffer."]
    #[doc = "-# Allocates appropriate memory for it."]
    #[doc = "-# Binds the buffer with the memory."]
    #[doc = ""]
    #[doc = "If any of these operations fail, buffer and allocation are not created,"]
    #[doc = "returned value is negative error code, `*pBuffer` and `*pAllocation` are null."]
    #[doc = ""]
    #[doc = "If the function succeeded, you must destroy both buffer and allocation when you"]
    #[doc = "no longer need them using either convenience function vmaDestroyBuffer() or"]
    #[doc = "separately, using `vkDestroyBuffer()` and vmaFreeMemory()."]
    #[doc = ""]
    #[doc = "If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,"]
    #[doc = "VK_KHR_dedicated_allocation extension is used internally to query driver whether"]
    #[doc = "it requires or prefers the new buffer to have dedicated allocation. If yes,"]
    #[doc = "and if dedicated allocation is possible"]
    #[doc = "(#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated"]
    #[doc = "allocation for this buffer, just like when using"]
    #[doc = "#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT."]
    #[doc = ""]
    #[doc = "\\note This function creates a new `VkBuffer`. Sub-allocation of parts of one large buffer,"]
    #[doc = "although recommended as a good practice, is out of scope of this library and could be implemented"]
    #[doc = "by the user as a higher-level logic on top of VMA."]
    pub fn vmaCreateBuffer(
        allocator: VmaAllocator,
        pBufferCreateInfo: *const VkBufferCreateInfo,
        pAllocationCreateInfo: *const VmaAllocationCreateInfo,
        pBuffer: *mut VkBuffer,
        pAllocation: *mut VmaAllocation,
        pAllocationInfo: *mut VmaAllocationInfo,
    ) -> VkResult;
}
extern "C" {
    #[doc = " \\brief Creates a buffer with additional minimum alignment."]
    #[doc = ""]
    #[doc = "Similar to vmaCreateBuffer() but provides additional parameter `minAlignment` which allows to specify custom,"]
    #[doc = "minimum alignment to be used when placing the buffer inside a larger memory block, which may be needed e.g."]
    #[doc = "for interop with OpenGL."]
    pub fn vmaCreateBufferWithAlignment(
        allocator: VmaAllocator,
        pBufferCreateInfo: *const VkBufferCreateInfo,
        pAllocationCreateInfo: *const VmaAllocationCreateInfo,
        minAlignment: VkDeviceSize,
        pBuffer: *mut VkBuffer,
        pAllocation: *mut VmaAllocation,
        pAllocationInfo: *mut VmaAllocationInfo,
    ) -> VkResult;
}
extern "C" {
    #[doc = " \\brief Creates a new `VkBuffer`, binds already created memory for it."]
    #[doc = ""]
    #[doc = "\\param allocator"]
    #[doc = "\\param allocation Allocation that provides memory to be used for binding new buffer to it."]
    #[doc = "\\param pBufferCreateInfo"]
    #[doc = "\\param[out] pBuffer Buffer that was created."]
    #[doc = ""]
    #[doc = "This function automatically:"]
    #[doc = ""]
    #[doc = "-# Creates buffer."]
    #[doc = "-# Binds the buffer with the supplied memory."]
    #[doc = ""]
    #[doc = "If any of these operations fail, buffer is not created,"]
    #[doc = "returned value is negative error code and `*pBuffer` is null."]
    #[doc = ""]
    #[doc = "If the function succeeded, you must destroy the buffer when you"]
    #[doc = "no longer need it using `vkDestroyBuffer()`. If you want to also destroy the corresponding"]
    #[doc = "allocation you can use convenience function vmaDestroyBuffer()."]
    pub fn vmaCreateAliasingBuffer(
        allocator: VmaAllocator,
        allocation: VmaAllocation,
        pBufferCreateInfo: *const VkBufferCreateInfo,
        pBuffer: *mut VkBuffer,
    ) -> VkResult;
}
extern "C" {
    #[doc = " \\brief Destroys Vulkan buffer and frees allocated memory."]
    #[doc = ""]
    #[doc = "This is just a convenience function equivalent to:"]
    #[doc = ""]
    #[doc = "\\code"]
    #[doc = "vkDestroyBuffer(device, buffer, allocationCallbacks);"]
    #[doc = "vmaFreeMemory(allocator, allocation);"]
    #[doc = "\\endcode"]
    #[doc = ""]
    #[doc = "It it safe to pass null as buffer and/or allocation."]
    pub fn vmaDestroyBuffer(allocator: VmaAllocator, buffer: VkBuffer, allocation: VmaAllocation);
}
extern "C" {
    #[doc = " Function similar to vmaCreateBuffer()."]
    pub fn vmaCreateImage(
        allocator: VmaAllocator,
        pImageCreateInfo: *const VkImageCreateInfo,
        pAllocationCreateInfo: *const VmaAllocationCreateInfo,
        pImage: *mut VkImage,
        pAllocation: *mut VmaAllocation,
        pAllocationInfo: *mut VmaAllocationInfo,
    ) -> VkResult;
}
extern "C" {
    #[doc = " Function similar to vmaCreateAliasingBuffer()."]
    pub fn vmaCreateAliasingImage(
        allocator: VmaAllocator,
        allocation: VmaAllocation,
        pImageCreateInfo: *const VkImageCreateInfo,
        pImage: *mut VkImage,
    ) -> VkResult;
}
extern "C" {
    #[doc = " \\brief Destroys Vulkan image and frees allocated memory."]
    #[doc = ""]
    #[doc = "This is just a convenience function equivalent to:"]
    #[doc = ""]
    #[doc = "\\code"]
    #[doc = "vkDestroyImage(device, image, allocationCallbacks);"]
    #[doc = "vmaFreeMemory(allocator, allocation);"]
    #[doc = "\\endcode"]
    #[doc = ""]
    #[doc = "It it safe to pass null as image and/or allocation."]
    pub fn vmaDestroyImage(allocator: VmaAllocator, image: VkImage, allocation: VmaAllocation);
}
extern "C" {
    #[doc = " \\brief Creates new #VmaVirtualBlock object."]
    #[doc = ""]
    #[doc = "\\param pCreateInfo Parameters for creation."]
    #[doc = "\\param[out] pVirtualBlock Returned virtual block object or `VMA_NULL` if creation failed."]
    pub fn vmaCreateVirtualBlock(
        pCreateInfo: *const VmaVirtualBlockCreateInfo,
        pVirtualBlock: *mut VmaVirtualBlock,
    ) -> VkResult;
}
extern "C" {
    #[doc = " \\brief Destroys #VmaVirtualBlock object."]
    #[doc = ""]
    #[doc = "Please note that you should consciously handle virtual allocations that could remain unfreed in the block."]
    #[doc = "You should either free them individually using vmaVirtualFree() or call vmaClearVirtualBlock()"]
    #[doc = "if you are sure this is what you want. If you do neither, an assert is called."]
    #[doc = ""]
    #[doc = "If you keep pointers to some additional metadata associated with your virtual allocations in their `pUserData`,"]
    #[doc = "don't forget to free them."]
    pub fn vmaDestroyVirtualBlock(virtualBlock: VmaVirtualBlock);
}
extern "C" {
    #[doc = " \\brief Returns true of the #VmaVirtualBlock is empty - contains 0 virtual allocations and has all its space available for new allocations."]
    pub fn vmaIsVirtualBlockEmpty(virtualBlock: VmaVirtualBlock) -> VkBool32;
}
extern "C" {
    #[doc = " \\brief Returns information about a specific virtual allocation within a virtual block, like its size and `pUserData` pointer."]
    pub fn vmaGetVirtualAllocationInfo(
        virtualBlock: VmaVirtualBlock,
        allocation: VmaVirtualAllocation,
        pVirtualAllocInfo: *mut VmaVirtualAllocationInfo,
    );
}
extern "C" {
    #[doc = " \\brief Allocates new virtual allocation inside given #VmaVirtualBlock."]
    #[doc = ""]
    #[doc = "If the allocation fails due to not enough free space available, `VK_ERROR_OUT_OF_DEVICE_MEMORY` is returned"]
    #[doc = "(despite the function doesn't ever allocate actual GPU memory)."]
    #[doc = "`pAllocation` is then set to `VK_NULL_HANDLE` and `pOffset`, if not null, it set to `UINT64_MAX`."]
    #[doc = ""]
    #[doc = "\\param virtualBlock Virtual block"]
    #[doc = "\\param pCreateInfo Parameters for the allocation"]
    #[doc = "\\param[out] pAllocation Returned handle of the new allocation"]
    #[doc = "\\param[out] pOffset Returned offset of the new allocation. Optional, can be null."]
    pub fn vmaVirtualAllocate(
        virtualBlock: VmaVirtualBlock,
        pCreateInfo: *const VmaVirtualAllocationCreateInfo,
        pAllocation: *mut VmaVirtualAllocation,
        pOffset: *mut VkDeviceSize,
    ) -> VkResult;
}
extern "C" {
    #[doc = " \\brief Frees virtual allocation inside given #VmaVirtualBlock."]
    #[doc = ""]
    #[doc = "It is correct to call this function with `allocation == VK_NULL_HANDLE` - it does nothing."]
    pub fn vmaVirtualFree(virtualBlock: VmaVirtualBlock, allocation: VmaVirtualAllocation);
}
extern "C" {
    #[doc = " \\brief Frees all virtual allocations inside given #VmaVirtualBlock."]
    #[doc = ""]
    #[doc = "You must either call this function or free each virtual allocation individually with vmaVirtualFree()"]
    #[doc = "before destroying a virtual block. Otherwise, an assert is called."]
    #[doc = ""]
    #[doc = "If you keep pointer to some additional metadata associated with your virtual allocation in its `pUserData`,"]
    #[doc = "don't forget to free it as well."]
    pub fn vmaClearVirtualBlock(virtualBlock: VmaVirtualBlock);
}
extern "C" {
    #[doc = " \\brief Changes custom pointer associated with given virtual allocation."]
    pub fn vmaSetVirtualAllocationUserData(
        virtualBlock: VmaVirtualBlock,
        allocation: VmaVirtualAllocation,
        pUserData: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " \\brief Calculates and returns statistics about virtual allocations and memory usage in given #VmaVirtualBlock."]
    #[doc = ""]
    #[doc = "This function is fast to call. For more detailed statistics, see vmaCalculateVirtualBlockStatistics()."]
    pub fn vmaGetVirtualBlockStatistics(virtualBlock: VmaVirtualBlock, pStats: *mut VmaStatistics);
}
extern "C" {
    #[doc = " \\brief Calculates and returns detailed statistics about virtual allocations and memory usage in given #VmaVirtualBlock."]
    #[doc = ""]
    #[doc = "This function is slow to call. Use for debugging purposes."]
    #[doc = "For less detailed statistics, see vmaGetVirtualBlockStatistics()."]
    pub fn vmaCalculateVirtualBlockStatistics(
        virtualBlock: VmaVirtualBlock,
        pStats: *mut VmaDetailedStatistics,
    );
}
extern "C" {
    #[doc = " \\brief Builds and returns a null-terminated string in JSON format with information about given #VmaVirtualBlock."]
    #[doc = "\\param virtualBlock Virtual block."]
    #[doc = "\\param[out] ppStatsString Returned string."]
    #[doc = "\\param detailedMap Pass `VK_FALSE` to only obtain statistics as returned by vmaCalculateVirtualBlockStatistics(). Pass `VK_TRUE` to also obtain full list of allocations and free spaces."]
    #[doc = ""]
    #[doc = "Returned string must be freed using vmaFreeVirtualBlockStatsString()."]
    pub fn vmaBuildVirtualBlockStatsString(
        virtualBlock: VmaVirtualBlock,
        ppStatsString: *mut *mut ::std::os::raw::c_char,
        detailedMap: VkBool32,
    );
}
extern "C" {
    #[doc = " Frees a string returned by vmaBuildVirtualBlockStatsString()."]
    pub fn vmaFreeVirtualBlockStatsString(
        virtualBlock: VmaVirtualBlock,
        pStatsString: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " \\brief Builds and returns statistics as a null-terminated string in JSON format."]
    #[doc = "\\param allocator"]
    #[doc = "\\param[out] ppStatsString Must be freed using vmaFreeStatsString() function."]
    #[doc = "\\param detailedMap"]
    pub fn vmaBuildStatsString(
        allocator: VmaAllocator,
        ppStatsString: *mut *mut ::std::os::raw::c_char,
        detailedMap: VkBool32,
    );
}
extern "C" {
    pub fn vmaFreeStatsString(allocator: VmaAllocator, pStatsString: *mut ::std::os::raw::c_char);
}
